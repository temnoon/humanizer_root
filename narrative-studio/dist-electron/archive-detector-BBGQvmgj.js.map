{"version":3,"file":"archive-detector-BBGQvmgj.js","sources":["../electron/archive-detector.ts"],"sourcesContent":["import { existsSync, statSync, readdirSync } from 'node:fs';\nimport path from 'node:path';\n\n/**\n * Archive detection result\n */\nexport interface ArchiveDetectionResult {\n  type: 'zip' | 'openai-export' | 'humanizer-archive' | 'unknown';\n  needsExtraction: boolean;\n  needsImport: boolean;\n  path: string;\n  estimatedSize?: number;\n  conversationCount?: number;\n}\n\n/**\n * Detect the type of archive from a path\n */\nexport async function detectArchiveType(archivePath: string): Promise<ArchiveDetectionResult> {\n  if (!existsSync(archivePath)) {\n    return {\n      type: 'unknown',\n      needsExtraction: false,\n      needsImport: false,\n      path: archivePath\n    };\n  }\n\n  const stats = statSync(archivePath);\n\n  // Check if it's a ZIP file\n  if (stats.isFile() && archivePath.toLowerCase().endsWith('.zip')) {\n    const fileSize = stats.size;\n    return {\n      type: 'zip',\n      needsExtraction: true,\n      needsImport: true,\n      path: archivePath,\n      estimatedSize: fileSize\n    };\n  }\n\n  // Check if it's a directory\n  if (stats.isDirectory()) {\n    // Check for Humanizer archive markers\n    const hasEmbeddingsDb = existsSync(path.join(archivePath, '.embeddings.db'));\n    const hasArchiveConfig = existsSync(path.join(archivePath, 'archive-config.json'));\n\n    if (hasEmbeddingsDb || hasArchiveConfig) {\n      // Count conversations in an existing archive\n      const conversationCount = countConversations(archivePath);\n      return {\n        type: 'humanizer-archive',\n        needsExtraction: false,\n        needsImport: false,\n        path: archivePath,\n        conversationCount\n      };\n    }\n\n    // Check for OpenAI export markers\n    const hasConversationsJson = existsSync(path.join(archivePath, 'conversations.json'));\n    const hasDatedFolders = checkForDatedFolders(archivePath);\n\n    if (hasConversationsJson || hasDatedFolders) {\n      const conversationCount = await countOpenAIConversations(archivePath);\n      return {\n        type: 'openai-export',\n        needsExtraction: false,\n        needsImport: true,\n        path: archivePath,\n        conversationCount\n      };\n    }\n  }\n\n  return {\n    type: 'unknown',\n    needsExtraction: false,\n    needsImport: false,\n    path: archivePath\n  };\n}\n\n/**\n * Check if directory contains dated folders (YYYY-MM-DD pattern)\n */\nfunction checkForDatedFolders(dirPath: string): boolean {\n  try {\n    const entries = readdirSync(dirPath);\n    const datePattern = /^\\d{4}-\\d{2}-\\d{2}/;\n    return entries.some(entry => datePattern.test(entry));\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Count conversations in a Humanizer archive\n */\nfunction countConversations(archivePath: string): number {\n  try {\n    const entries = readdirSync(archivePath);\n    // Count directories that look like conversation folders\n    return entries.filter(entry => {\n      const fullPath = path.join(archivePath, entry);\n      return statSync(fullPath).isDirectory() && !entry.startsWith('.');\n    }).length;\n  } catch {\n    return 0;\n  }\n}\n\n/**\n * Count conversations in an OpenAI export\n */\nasync function countOpenAIConversations(dirPath: string): Promise<number> {\n  const conversationsPath = path.join(dirPath, 'conversations.json');\n\n  if (existsSync(conversationsPath)) {\n    try {\n      const { readFile } = await import('node:fs/promises');\n      const content = await readFile(conversationsPath, 'utf-8');\n      const data = JSON.parse(content);\n      return Array.isArray(data) ? data.length : 0;\n    } catch {\n      return 0;\n    }\n  }\n\n  // Count dated folders\n  try {\n    const entries = readdirSync(dirPath);\n    const datePattern = /^\\d{4}-\\d{2}-\\d{2}/;\n    return entries.filter(entry => datePattern.test(entry)).length;\n  } catch {\n    return 0;\n  }\n}\n\n/**\n * Validate that a path is a valid archive location\n */\nexport function isValidArchiveLocation(archivePath: string): { valid: boolean; reason?: string } {\n  if (!existsSync(archivePath)) {\n    return { valid: false, reason: 'Path does not exist' };\n  }\n\n  const stats = statSync(archivePath);\n  if (!stats.isDirectory()) {\n    return { valid: false, reason: 'Path is not a directory' };\n  }\n\n  // Check if writable\n  try {\n    const testPath = path.join(archivePath, '.write-test');\n    const { writeFileSync, unlinkSync } = require('fs');\n    writeFileSync(testPath, '');\n    unlinkSync(testPath);\n    return { valid: true };\n  } catch {\n    return { valid: false, reason: 'Directory is not writable' };\n  }\n}\n"],"names":[],"mappings":";;AAkBA,eAAsB,kBAAkB,aAAsD;AAC5F,MAAI,CAAC,WAAW,WAAW,GAAG;AAC5B,WAAO;AAAA,MACL,MAAM;AAAA,MACN,iBAAiB;AAAA,MACjB,aAAa;AAAA,MACb,MAAM;AAAA,IAAA;AAAA,EAEV;AAEA,QAAM,QAAQ,SAAS,WAAW;AAGlC,MAAI,MAAM,YAAY,YAAY,cAAc,SAAS,MAAM,GAAG;AAChE,UAAM,WAAW,MAAM;AACvB,WAAO;AAAA,MACL,MAAM;AAAA,MACN,iBAAiB;AAAA,MACjB,aAAa;AAAA,MACb,MAAM;AAAA,MACN,eAAe;AAAA,IAAA;AAAA,EAEnB;AAGA,MAAI,MAAM,eAAe;AAEvB,UAAM,kBAAkB,WAAW,KAAK,KAAK,aAAa,gBAAgB,CAAC;AAC3E,UAAM,mBAAmB,WAAW,KAAK,KAAK,aAAa,qBAAqB,CAAC;AAEjF,QAAI,mBAAmB,kBAAkB;AAEvC,YAAM,oBAAoB,mBAAmB,WAAW;AACxD,aAAO;AAAA,QACL,MAAM;AAAA,QACN,iBAAiB;AAAA,QACjB,aAAa;AAAA,QACb,MAAM;AAAA,QACN;AAAA,MAAA;AAAA,IAEJ;AAGA,UAAM,uBAAuB,WAAW,KAAK,KAAK,aAAa,oBAAoB,CAAC;AACpF,UAAM,kBAAkB,qBAAqB,WAAW;AAExD,QAAI,wBAAwB,iBAAiB;AAC3C,YAAM,oBAAoB,MAAM,yBAAyB,WAAW;AACpE,aAAO;AAAA,QACL,MAAM;AAAA,QACN,iBAAiB;AAAA,QACjB,aAAa;AAAA,QACb,MAAM;AAAA,QACN;AAAA,MAAA;AAAA,IAEJ;AAAA,EACF;AAEA,SAAO;AAAA,IACL,MAAM;AAAA,IACN,iBAAiB;AAAA,IACjB,aAAa;AAAA,IACb,MAAM;AAAA,EAAA;AAEV;AAKA,SAAS,qBAAqB,SAA0B;AACtD,MAAI;AACF,UAAM,UAAU,YAAY,OAAO;AACnC,UAAM,cAAc;AACpB,WAAO,QAAQ,KAAK,CAAA,UAAS,YAAY,KAAK,KAAK,CAAC;AAAA,EACtD,QAAQ;AACN,WAAO;AAAA,EACT;AACF;AAKA,SAAS,mBAAmB,aAA6B;AACvD,MAAI;AACF,UAAM,UAAU,YAAY,WAAW;AAEvC,WAAO,QAAQ,OAAO,CAAA,UAAS;AAC7B,YAAM,WAAW,KAAK,KAAK,aAAa,KAAK;AAC7C,aAAO,SAAS,QAAQ,EAAE,YAAA,KAAiB,CAAC,MAAM,WAAW,GAAG;AAAA,IAClE,CAAC,EAAE;AAAA,EACL,QAAQ;AACN,WAAO;AAAA,EACT;AACF;AAKA,eAAe,yBAAyB,SAAkC;AACxE,QAAM,oBAAoB,KAAK,KAAK,SAAS,oBAAoB;AAEjE,MAAI,WAAW,iBAAiB,GAAG;AACjC,QAAI;AACF,YAAM,EAAE,SAAA,IAAa,MAAM,OAAO,kBAAkB;AACpD,YAAM,UAAU,MAAM,SAAS,mBAAmB,OAAO;AACzD,YAAM,OAAO,KAAK,MAAM,OAAO;AAC/B,aAAO,MAAM,QAAQ,IAAI,IAAI,KAAK,SAAS;AAAA,IAC7C,QAAQ;AACN,aAAO;AAAA,IACT;AAAA,EACF;AAGA,MAAI;AACF,UAAM,UAAU,YAAY,OAAO;AACnC,UAAM,cAAc;AACpB,WAAO,QAAQ,OAAO,CAAA,UAAS,YAAY,KAAK,KAAK,CAAC,EAAE;AAAA,EAC1D,QAAQ;AACN,WAAO;AAAA,EACT;AACF;"}