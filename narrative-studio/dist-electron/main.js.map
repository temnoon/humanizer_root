{"version":3,"file":"main.js","sources":["../electron/ipc-handlers.ts","../electron/ollama-manager.ts","../electron/app-paths.ts","../electron/main.ts"],"sourcesContent":["import { ipcMain, dialog, BrowserWindow } from 'electron';\nimport { statfs } from 'node:fs/promises';\nimport { existsSync } from 'node:fs';\nimport path from 'node:path';\n\n/**\n * Register additional IPC handlers for file operations\n * These handlers are registered separately from the core handlers in main.ts\n */\nexport function registerFileHandlers() {\n  // Select folder dialog\n  ipcMain.handle('select-folder', async () => {\n    const window = BrowserWindow.getFocusedWindow();\n    const result = await dialog.showOpenDialog(window!, {\n      properties: ['openDirectory', 'createDirectory'],\n      title: 'Select Archive Folder',\n      buttonLabel: 'Select'\n    });\n\n    if (result.canceled || result.filePaths.length === 0) {\n      return null;\n    }\n\n    return result.filePaths[0];\n  });\n\n  // Select archive (file or folder)\n  ipcMain.handle('select-archive', async () => {\n    const window = BrowserWindow.getFocusedWindow();\n    const result = await dialog.showOpenDialog(window!, {\n      properties: ['openFile', 'openDirectory'],\n      title: 'Select Archive',\n      buttonLabel: 'Import',\n      filters: [\n        { name: 'Archives', extensions: ['zip'] },\n        { name: 'All Files', extensions: ['*'] }\n      ]\n    });\n\n    if (result.canceled || result.filePaths.length === 0) {\n      return null;\n    }\n\n    return result.filePaths[0];\n  });\n\n  // Get disk space for a path\n  ipcMain.handle('get-disk-space', async (_event, targetPath: string) => {\n    try {\n      // Use the parent directory if the path doesn't exist\n      let checkPath = targetPath;\n      while (!existsSync(checkPath) && checkPath !== path.dirname(checkPath)) {\n        checkPath = path.dirname(checkPath);\n      }\n\n      const stats = await statfs(checkPath);\n      return {\n        free: stats.bfree * stats.bsize,\n        total: stats.blocks * stats.bsize\n      };\n    } catch (error) {\n      console.error('Failed to get disk space:', error);\n      return {\n        free: 0,\n        total: 0\n      };\n    }\n  });\n}\n\n/**\n * Archive detection result\n */\nexport interface ArchiveDetectionResult {\n  type: 'zip' | 'openai-export' | 'humanizer-archive' | 'unknown';\n  needsExtraction: boolean;\n  needsImport: boolean;\n  path: string;\n  estimatedSize?: number;\n  conversationCount?: number;\n}\n\n/**\n * Register archive detection handlers\n */\nexport function registerArchiveHandlers() {\n  // Detect archive type\n  ipcMain.handle('detect-archive', async (_event, archivePath: string): Promise<ArchiveDetectionResult> => {\n    const { detectArchiveType } = await import('./archive-detector.js');\n    return detectArchiveType(archivePath);\n  });\n\n  // Validate archive path\n  ipcMain.handle('validate-archive-path', async (_event, archivePath: string) => {\n    try {\n      if (!existsSync(archivePath)) {\n        return { valid: false, error: 'Path does not exist' };\n      }\n\n      // Check if we can write to parent directory\n      const parentDir = path.dirname(archivePath);\n      try {\n        await import('node:fs/promises').then(fs => fs.access(parentDir, fs.constants.W_OK));\n        return { valid: true };\n      } catch {\n        return { valid: false, error: 'Cannot write to directory' };\n      }\n    } catch (error) {\n      return { valid: false, error: String(error) };\n    }\n  });\n}\n\n/**\n * Register all IPC handlers\n */\nexport function registerAllIPCHandlers() {\n  registerFileHandlers();\n  registerArchiveHandlers();\n}\n","import { ipcMain, BrowserWindow } from 'electron';\nimport { spawn, ChildProcess, execSync } from 'node:child_process';\n\nconst OLLAMA_ENDPOINT = 'http://localhost:11434';\n\n/**\n * Ollama status\n */\nexport interface OllamaStatus {\n  installed: boolean;\n  running: boolean;\n  version?: string;\n  endpoint: string;\n}\n\n/**\n * Ollama model info\n */\nexport interface OllamaModel {\n  name: string;\n  size: number;\n  modified: string;\n  digest: string;\n}\n\n/**\n * Ollama pull progress\n */\nexport interface OllamaPullProgress {\n  model: string;\n  status: string;\n  completed: number;\n  total: number;\n  percent: number;\n}\n\n// Keep track of any Ollama process we started\nlet ollamaProcess: ChildProcess | null = null;\n\n/**\n * Check if Ollama is installed\n */\nexport function isOllamaInstalled(): boolean {\n  try {\n    // Check if ollama binary exists in PATH\n    execSync('which ollama', { stdio: 'ignore' });\n    return true;\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Get Ollama version\n */\nexport function getOllamaVersion(): string | null {\n  try {\n    const output = execSync('ollama --version', { encoding: 'utf-8' });\n    // Extract version from output like \"ollama version 0.1.23\"\n    const match = output.match(/(\\d+\\.\\d+\\.\\d+)/);\n    return match ? match[1] : null;\n  } catch {\n    return null;\n  }\n}\n\n/**\n * Check if Ollama server is running\n */\nexport async function isOllamaRunning(): Promise<boolean> {\n  try {\n    const response = await fetch(`${OLLAMA_ENDPOINT}/api/tags`);\n    return response.ok;\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Get full Ollama status\n */\nexport async function getOllamaStatus(): Promise<OllamaStatus> {\n  const installed = isOllamaInstalled();\n  const running = await isOllamaRunning();\n  const version = installed ? getOllamaVersion() : undefined;\n\n  return {\n    installed,\n    running,\n    version: version ?? undefined,\n    endpoint: OLLAMA_ENDPOINT\n  };\n}\n\n/**\n * Start Ollama server\n */\nexport async function startOllamaServer(): Promise<boolean> {\n  if (await isOllamaRunning()) {\n    return true; // Already running\n  }\n\n  if (!isOllamaInstalled()) {\n    return false;\n  }\n\n  return new Promise((resolve) => {\n    try {\n      ollamaProcess = spawn('ollama', ['serve'], {\n        detached: true,\n        stdio: 'ignore'\n      });\n\n      ollamaProcess.unref();\n\n      // Wait for server to start\n      let attempts = 0;\n      const checkInterval = setInterval(async () => {\n        attempts++;\n        if (await isOllamaRunning()) {\n          clearInterval(checkInterval);\n          resolve(true);\n        } else if (attempts > 10) {\n          clearInterval(checkInterval);\n          resolve(false);\n        }\n      }, 500);\n    } catch (error) {\n      console.error('Failed to start Ollama:', error);\n      resolve(false);\n    }\n  });\n}\n\n/**\n * Stop Ollama server (only if we started it)\n */\nexport async function stopOllamaServer(): Promise<boolean> {\n  if (ollamaProcess) {\n    ollamaProcess.kill();\n    ollamaProcess = null;\n    return true;\n  }\n  return false;\n}\n\n/**\n * List installed models\n */\nexport async function listModels(): Promise<OllamaModel[]> {\n  try {\n    const response = await fetch(`${OLLAMA_ENDPOINT}/api/tags`);\n    if (!response.ok) {\n      return [];\n    }\n\n    const data = await response.json();\n    return (data.models || []).map((model: any) => ({\n      name: model.name,\n      size: model.size,\n      modified: model.modified_at,\n      digest: model.digest\n    }));\n  } catch {\n    return [];\n  }\n}\n\n/**\n * Pull a model with progress updates\n */\nexport async function pullModel(\n  modelName: string,\n  onProgress?: (progress: OllamaPullProgress) => void\n): Promise<boolean> {\n  try {\n    const response = await fetch(`${OLLAMA_ENDPOINT}/api/pull`, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({ name: modelName })\n    });\n\n    if (!response.ok || !response.body) {\n      return false;\n    }\n\n    const reader = response.body.getReader();\n    const decoder = new TextDecoder();\n\n    while (true) {\n      const { done, value } = await reader.read();\n      if (done) break;\n\n      const chunk = decoder.decode(value, { stream: true });\n      const lines = chunk.split('\\n').filter(Boolean);\n\n      for (const line of lines) {\n        try {\n          const data = JSON.parse(line);\n\n          if (onProgress && data.total) {\n            onProgress({\n              model: modelName,\n              status: data.status || 'downloading',\n              completed: data.completed || 0,\n              total: data.total || 0,\n              percent: data.total ? Math.round((data.completed / data.total) * 100) : 0\n            });\n          }\n\n          if (data.status === 'success') {\n            return true;\n          }\n        } catch {\n          // Ignore JSON parse errors\n        }\n      }\n    }\n\n    return true;\n  } catch (error) {\n    console.error('Failed to pull model:', error);\n    return false;\n  }\n}\n\n/**\n * Generate text with Ollama\n */\nexport async function generate(\n  prompt: string,\n  model: string = 'llama3.2:3b'\n): Promise<string> {\n  const response = await fetch(`${OLLAMA_ENDPOINT}/api/generate`, {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({\n      model,\n      prompt,\n      stream: false\n    })\n  });\n\n  if (!response.ok) {\n    throw new Error(`Ollama generate failed: ${response.statusText}`);\n  }\n\n  const data = await response.json();\n  return data.response;\n}\n\n/**\n * Register Ollama IPC handlers\n */\nexport function registerOllamaHandlers() {\n  ipcMain.handle('ollama-status', async () => {\n    return getOllamaStatus();\n  });\n\n  ipcMain.handle('ollama-start', async () => {\n    return startOllamaServer();\n  });\n\n  ipcMain.handle('ollama-stop', async () => {\n    return stopOllamaServer();\n  });\n\n  ipcMain.handle('ollama-list-models', async () => {\n    return listModels();\n  });\n\n  ipcMain.handle('ollama-pull', async (event, modelName: string) => {\n    const window = BrowserWindow.fromWebContents(event.sender);\n\n    return pullModel(modelName, (progress) => {\n      // Send progress to renderer\n      window?.webContents.send('ollama-progress', progress);\n    });\n  });\n\n  ipcMain.handle('ollama-generate', async (_event, prompt: string, model?: string) => {\n    return generate(prompt, model);\n  });\n}\n","import { app } from 'electron';\nimport path from 'node:path';\nimport Store from 'electron-store';\n\nconst store = new Store();\n\n/**\n * Application paths configuration\n * All paths are resolved dynamically based on app state and user settings\n */\nexport const paths = {\n  /**\n   * Default archive storage location\n   * User can customize this during setup\n   */\n  archives: (): string => {\n    const customPath = store.get('archivePath') as string | null;\n    if (customPath) {\n      return customPath;\n    }\n    return path.join(app.getPath('documents'), 'Humanizer Archives');\n  },\n\n  /**\n   * Session data storage (history buffer, pinned items, etc.)\n   */\n  sessions: (): string => {\n    return path.join(app.getPath('userData'), 'sessions');\n  },\n\n  /**\n   * Downloaded ML models (if we ever bundle any locally)\n   */\n  models: (): string => {\n    return path.join(app.getPath('userData'), 'models');\n  },\n\n  /**\n   * Temporary file storage (uploads, extractions, etc.)\n   */\n  temp: (): string => {\n    return path.join(app.getPath('temp'), 'humanizer-studio');\n  },\n\n  /**\n   * Application logs\n   */\n  logs: (): string => {\n    return path.join(app.getPath('logs'), 'humanizer-studio');\n  },\n\n  /**\n   * User data directory (settings, cache, etc.)\n   */\n  userData: (): string => {\n    return app.getPath('userData');\n  },\n\n  /**\n   * Get the path to a specific archive by name\n   */\n  archive: (name: string): string => {\n    return path.join(paths.archives(), name);\n  },\n\n  /**\n   * Get the embeddings database path for an archive\n   */\n  archiveEmbeddings: (archiveName: string): string => {\n    return path.join(paths.archive(archiveName), '.embeddings.db');\n  },\n\n  /**\n   * Get the config file path for an archive\n   */\n  archiveConfig: (archiveName: string): string => {\n    return path.join(paths.archive(archiveName), 'archive-config.json');\n  }\n};\n\n/**\n * Ensure a directory exists\n */\nexport async function ensureDir(dirPath: string): Promise<void> {\n  const { mkdir } = await import('node:fs/promises');\n  await mkdir(dirPath, { recursive: true });\n}\n\n/**\n * Ensure all app directories exist\n */\nexport async function ensureAppDirectories(): Promise<void> {\n  await Promise.all([\n    ensureDir(paths.archives()),\n    ensureDir(paths.sessions()),\n    ensureDir(paths.models()),\n    ensureDir(paths.temp()),\n    ensureDir(paths.logs())\n  ]);\n}\n\n/**\n * Get all paths as a plain object (for IPC)\n */\nexport function getAllPaths(): Record<string, string> {\n  return {\n    archives: paths.archives(),\n    sessions: paths.sessions(),\n    models: paths.models(),\n    temp: paths.temp(),\n    logs: paths.logs(),\n    userData: paths.userData()\n  };\n}\n","import { app, BrowserWindow, shell, ipcMain } from 'electron';\nimport { fileURLToPath } from 'node:url';\nimport path from 'node:path';\nimport { spawn, ChildProcess } from 'node:child_process';\nimport { createServer } from 'node:net';\nimport Store from 'electron-store';\nimport { registerAllIPCHandlers } from './ipc-handlers.js';\nimport { registerOllamaHandlers } from './ollama-manager.js';\nimport { ensureAppDirectories } from './app-paths.js';\n\n// ES Module __dirname equivalent\nconst __filename = fileURLToPath(import.meta.url);\nconst __dirname = path.dirname(__filename);\n\n// Paths\nconst RENDERER_DEV_URL = process.env.VITE_DEV_SERVER_URL;\nconst DIST = path.join(__dirname, '../dist');\nconst DIST_ELECTRON = path.join(__dirname, '../dist-electron');\n\n// Initialize store for persistent settings\nconst store = new Store({\n  defaults: {\n    archivePath: null,\n    ollamaModel: 'llama3.2:3b',\n    provider: 'local',\n    cloudToken: null,\n    firstRunComplete: false,\n    windowBounds: { width: 1400, height: 900, x: undefined, y: undefined }\n  }\n});\n\n// Keep references to prevent garbage collection\nlet mainWindow: BrowserWindow | null = null;\nlet archiveServerProcess: ChildProcess | null = null;\nlet archiveServerPort: number | null = null;\n\n/**\n * Find an available port\n */\nasync function findFreePort(): Promise<number> {\n  return new Promise((resolve, reject) => {\n    const server = createServer();\n    server.listen(0, () => {\n      const address = server.address();\n      if (address && typeof address === 'object') {\n        const port = address.port;\n        server.close(() => resolve(port));\n      } else {\n        reject(new Error('Could not get port'));\n      }\n    });\n    server.on('error', reject);\n  });\n}\n\n/**\n * Check if archive server is already running\n */\nasync function checkExternalServer(port: number): Promise<boolean> {\n  try {\n    const response = await fetch(`http://localhost:${port}/health`);\n    return response.ok;\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Start the archive server as a child process\n */\nasync function startArchiveServer(): Promise<number> {\n  // In development, check if server is already running externally (e.g., via `npx tsx archive-server.js`)\n  const devPort = 3002;\n  if (!app.isPackaged) {\n    const externalRunning = await checkExternalServer(devPort);\n    if (externalRunning) {\n      console.log(`Using external archive server on port ${devPort}`);\n      archiveServerPort = devPort;\n      return devPort;\n    }\n    console.log('No external archive server found, starting internal server...');\n  }\n\n  const port = app.isPackaged ? await findFreePort() : devPort;\n\n  // Path to archive-server.js\n  const serverPath = app.isPackaged\n    ? path.join(process.resourcesPath, 'archive-server.js')\n    : path.join(__dirname, '../archive-server.js');\n\n  console.log(`Starting archive server on port ${port}...`);\n  console.log(`Server path: ${serverPath}`);\n\n  // Get archive path from store (if configured during setup)\n  const archivePath = store.get('archivePath') as string | null;\n  if (archivePath) {\n    console.log(`Using archive path from settings: ${archivePath}`);\n  }\n\n  // Use node for packaged app, npx tsx for development\n  const command = app.isPackaged ? 'node' : 'npx';\n  const args = app.isPackaged ? [serverPath] : ['tsx', serverPath];\n\n  // Build environment with optional ARCHIVE_PATH\n  const serverEnv: Record<string, string> = {\n    ...process.env as Record<string, string>,\n    PORT: port.toString(),\n    NODE_OPTIONS: '--max-old-space-size=8192'\n  };\n\n  // Only set ARCHIVE_PATH if configured (custom archive mode)\n  if (archivePath) {\n    serverEnv.ARCHIVE_PATH = archivePath;\n  }\n\n  archiveServerProcess = spawn(command, args, {\n    env: serverEnv,\n    cwd: path.dirname(serverPath),\n    stdio: ['ignore', 'pipe', 'pipe'],\n    detached: false\n  });\n\n  archiveServerProcess.stdout?.on('data', (data) => {\n    console.log(`[Archive Server] ${data}`);\n  });\n\n  archiveServerProcess.stderr?.on('data', (data) => {\n    console.error(`[Archive Server Error] ${data}`);\n  });\n\n  archiveServerProcess.on('error', (err) => {\n    console.error('Failed to start archive server:', err);\n  });\n\n  archiveServerProcess.on('exit', (code) => {\n    console.log(`Archive server exited with code ${code}`);\n    archiveServerProcess = null;\n  });\n\n  // Wait for server to be ready\n  await waitForServer(port);\n\n  archiveServerPort = port;\n  return port;\n}\n\n/**\n * Wait for server to be ready\n */\nasync function waitForServer(port: number, maxAttempts = 30): Promise<void> {\n  for (let i = 0; i < maxAttempts; i++) {\n    try {\n      const response = await fetch(`http://localhost:${port}/api/archives`);\n      if (response.ok) {\n        console.log(`Archive server ready on port ${port}`);\n        return;\n      }\n    } catch {\n      // Server not ready yet\n    }\n    await new Promise(resolve => setTimeout(resolve, 500));\n  }\n  throw new Error('Archive server failed to start');\n}\n\n/**\n * Create the main application window\n */\nasync function createWindow() {\n  // Get saved window bounds\n  const bounds = store.get('windowBounds') as { width: number; height: number; x?: number; y?: number };\n\n  mainWindow = new BrowserWindow({\n    width: bounds.width,\n    height: bounds.height,\n    x: bounds.x,\n    y: bounds.y,\n    minWidth: 1024,\n    minHeight: 768,\n    titleBarStyle: 'hiddenInset',\n    trafficLightPosition: { x: 16, y: 16 },\n    webPreferences: {\n      preload: path.join(__dirname, 'preload.js'),\n      nodeIntegration: false,\n      contextIsolation: true,\n      sandbox: false // Required for better-sqlite3\n    },\n    show: false, // Don't show until ready\n    backgroundColor: '#1a1a2e'\n  });\n\n  // Save window bounds on resize/move\n  mainWindow.on('resized', () => {\n    if (mainWindow) {\n      const bounds = mainWindow.getBounds();\n      store.set('windowBounds', bounds);\n    }\n  });\n\n  mainWindow.on('moved', () => {\n    if (mainWindow) {\n      const bounds = mainWindow.getBounds();\n      store.set('windowBounds', bounds);\n    }\n  });\n\n  // Show window when ready\n  mainWindow.on('ready-to-show', () => {\n    mainWindow?.show();\n  });\n\n  // Handle external links\n  mainWindow.webContents.setWindowOpenHandler(({ url }) => {\n    if (url.startsWith('https:') || url.startsWith('http:')) {\n      shell.openExternal(url);\n    }\n    return { action: 'deny' };\n  });\n\n  // Load the app\n  if (RENDERER_DEV_URL) {\n    // Development: load from Vite dev server\n    await mainWindow.loadURL(RENDERER_DEV_URL);\n    mainWindow.webContents.openDevTools();\n  } else {\n    // Production: load from dist\n    await mainWindow.loadFile(path.join(DIST, 'index.html'));\n  }\n}\n\n/**\n * Register IPC handlers\n */\nfunction registerIPCHandlers() {\n  // Store operations\n  ipcMain.handle('store-get', (_event, key: string) => {\n    return store.get(key);\n  });\n\n  ipcMain.handle('store-set', (_event, key: string, value: unknown) => {\n    store.set(key, value);\n    return true;\n  });\n\n  // Get archive server port\n  ipcMain.handle('get-archive-server-port', () => {\n    return archiveServerPort;\n  });\n\n  // Get app paths\n  ipcMain.handle('get-paths', () => {\n    return {\n      documents: app.getPath('documents'),\n      userData: app.getPath('userData'),\n      temp: app.getPath('temp'),\n      logs: app.getPath('logs'),\n      home: app.getPath('home')\n    };\n  });\n\n  // Check if first run\n  ipcMain.handle('is-first-run', () => {\n    return !store.get('firstRunComplete');\n  });\n\n  // Mark first run complete\n  ipcMain.handle('complete-first-run', () => {\n    store.set('firstRunComplete', true);\n    return true;\n  });\n\n  // Get platform info\n  ipcMain.handle('get-platform-info', () => {\n    return {\n      platform: process.platform,\n      arch: process.arch,\n      version: app.getVersion(),\n      isPackaged: app.isPackaged\n    };\n  });\n\n  // Restart archive server with new path\n  ipcMain.handle('restart-archive-server', async (_event, newArchivePath: string) => {\n    console.log(`Restarting archive server with new path: ${newArchivePath}`);\n\n    // Update the store\n    store.set('archivePath', newArchivePath);\n\n    // Kill existing server if running\n    if (archiveServerProcess) {\n      console.log('Stopping existing archive server...');\n      archiveServerProcess.kill();\n      archiveServerProcess = null;\n      archiveServerPort = null;\n\n      // Wait a bit for the process to terminate\n      await new Promise(resolve => setTimeout(resolve, 500));\n    }\n\n    // Start new server with updated path\n    try {\n      const port = await startArchiveServer();\n      return { success: true, port };\n    } catch (error) {\n      console.error('Failed to restart archive server:', error);\n      return { success: false, error: String(error) };\n    }\n  });\n\n  // Get current archive path\n  ipcMain.handle('get-archive-path', () => {\n    return store.get('archivePath') as string | null;\n  });\n}\n\n// App lifecycle\napp.whenReady().then(async () => {\n  console.log('Humanizer Studio starting...');\n\n  // Ensure app directories exist\n  await ensureAppDirectories();\n\n  // Register IPC handlers\n  registerIPCHandlers();\n  registerAllIPCHandlers();\n  registerOllamaHandlers();\n\n  // Start archive server\n  try {\n    await startArchiveServer();\n  } catch (err) {\n    console.error('Failed to start archive server:', err);\n    // Continue without server - will show error in UI\n  }\n\n  // Create main window\n  await createWindow();\n\n  // macOS: re-create window when dock icon clicked\n  app.on('activate', async () => {\n    if (BrowserWindow.getAllWindows().length === 0) {\n      await createWindow();\n    }\n  });\n});\n\n// Quit when all windows are closed (except on macOS)\napp.on('window-all-closed', () => {\n  // On macOS, apps typically stay active until explicitly quit\n  if (process.platform !== 'darwin') {\n    app.quit();\n  }\n});\n\n// Cleanup on quit\napp.on('before-quit', () => {\n  console.log('Shutting down...');\n\n  // Kill archive server\n  if (archiveServerProcess) {\n    archiveServerProcess.kill();\n    archiveServerProcess = null;\n  }\n});\n\n// Handle uncaught exceptions\nprocess.on('uncaughtException', (error) => {\n  console.error('Uncaught Exception:', error);\n});\n\nprocess.on('unhandledRejection', (reason, promise) => {\n  console.error('Unhandled Rejection at:', promise, 'reason:', reason);\n});\n"],"names":["registerFileHandlers","ipcMain","window","BrowserWindow","result","dialog","_event","targetPath","checkPath","existsSync","path","stats","statfs","error","registerArchiveHandlers","archivePath","detectArchiveType","parentDir","fs","registerAllIPCHandlers","OLLAMA_ENDPOINT","ollamaProcess","isOllamaInstalled","execSync","getOllamaVersion","match","isOllamaRunning","getOllamaStatus","installed","running","version","startOllamaServer","resolve","spawn","attempts","checkInterval","stopOllamaServer","listModels","response","model","pullModel","modelName","onProgress","reader","decoder","done","value","lines","line","data","generate","prompt","registerOllamaHandlers","event","progress","store","Store","paths","customPath","app","name","archiveName","ensureDir","dirPath","mkdir","ensureAppDirectories","__filename","fileURLToPath","__dirname","RENDERER_DEV_URL","DIST","mainWindow","archiveServerProcess","archiveServerPort","findFreePort","reject","server","createServer","address","port","checkExternalServer","startArchiveServer","serverPath","command","args","serverEnv","err","code","waitForServer","maxAttempts","i","createWindow","bounds","url","shell","registerIPCHandlers","key","newArchivePath","reason","promise"],"mappings":"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"}