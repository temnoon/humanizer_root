{"version":3,"file":"archive-detector-B0OossDK.js","sources":["../electron/archive-detector.ts"],"sourcesContent":["import { existsSync, statSync, readdirSync } from 'node:fs';\nimport path from 'node:path';\n\n/**\n * Archive detection result\n */\nexport interface ArchiveDetectionResult {\n  type: 'zip' | 'openai-export' | 'humanizer-archive' | 'unknown';\n  needsExtraction: boolean;\n  needsImport: boolean;\n  path: string;\n  estimatedSize?: number;\n  conversationCount?: number;\n}\n\n/**\n * Detect the type of archive from a path\n */\nexport async function detectArchiveType(archivePath: string): Promise<ArchiveDetectionResult> {\n  if (!existsSync(archivePath)) {\n    return {\n      type: 'unknown',\n      needsExtraction: false,\n      needsImport: false,\n      path: archivePath\n    };\n  }\n\n  const stats = statSync(archivePath);\n\n  // Check if it's a ZIP file\n  if (stats.isFile() && archivePath.toLowerCase().endsWith('.zip')) {\n    const fileSize = stats.size;\n    return {\n      type: 'zip',\n      needsExtraction: true,\n      needsImport: true,\n      path: archivePath,\n      estimatedSize: fileSize\n    };\n  }\n\n  // Check if it's a directory\n  if (stats.isDirectory()) {\n    // Check for Humanizer archive markers\n    const hasEmbeddingsDb = existsSync(path.join(archivePath, '.embeddings.db'));\n    const hasArchiveConfig = existsSync(path.join(archivePath, 'archive-config.json'));\n\n    if (hasEmbeddingsDb || hasArchiveConfig) {\n      // Count conversations in an existing archive\n      const conversationCount = countConversations(archivePath);\n      return {\n        type: 'humanizer-archive',\n        needsExtraction: false,\n        needsImport: false,\n        path: archivePath,\n        conversationCount\n      };\n    }\n\n    // Check for OpenAI export markers\n    const hasConversationsJson = existsSync(path.join(archivePath, 'conversations.json'));\n    const hasDatedFolders = checkForDatedFolders(archivePath);\n\n    if (hasConversationsJson || hasDatedFolders) {\n      const conversationCount = await countOpenAIConversations(archivePath);\n      return {\n        type: 'openai-export',\n        needsExtraction: false,\n        needsImport: true,\n        path: archivePath,\n        conversationCount\n      };\n    }\n  }\n\n  return {\n    type: 'unknown',\n    needsExtraction: false,\n    needsImport: false,\n    path: archivePath\n  };\n}\n\n/**\n * Check if directory contains dated folders (YYYY-MM-DD pattern)\n */\nfunction checkForDatedFolders(dirPath: string): boolean {\n  try {\n    const entries = readdirSync(dirPath);\n    const datePattern = /^\\d{4}-\\d{2}-\\d{2}/;\n    return entries.some(entry => datePattern.test(entry));\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Count conversations in a Humanizer archive\n */\nfunction countConversations(archivePath: string): number {\n  try {\n    const entries = readdirSync(archivePath);\n    // Count directories that look like conversation folders\n    return entries.filter(entry => {\n      const fullPath = path.join(archivePath, entry);\n      return statSync(fullPath).isDirectory() && !entry.startsWith('.');\n    }).length;\n  } catch {\n    return 0;\n  }\n}\n\n/**\n * Count conversations in an OpenAI export\n */\nasync function countOpenAIConversations(dirPath: string): Promise<number> {\n  const conversationsPath = path.join(dirPath, 'conversations.json');\n\n  if (existsSync(conversationsPath)) {\n    try {\n      const { readFile } = await import('node:fs/promises');\n      const content = await readFile(conversationsPath, 'utf-8');\n      const data = JSON.parse(content);\n      return Array.isArray(data) ? data.length : 0;\n    } catch {\n      return 0;\n    }\n  }\n\n  // Count dated folders\n  try {\n    const entries = readdirSync(dirPath);\n    const datePattern = /^\\d{4}-\\d{2}-\\d{2}/;\n    return entries.filter(entry => datePattern.test(entry)).length;\n  } catch {\n    return 0;\n  }\n}\n\n/**\n * Validate that a path is a valid archive location\n */\nexport function isValidArchiveLocation(archivePath: string): { valid: boolean; reason?: string } {\n  if (!existsSync(archivePath)) {\n    return { valid: false, reason: 'Path does not exist' };\n  }\n\n  const stats = statSync(archivePath);\n  if (!stats.isDirectory()) {\n    return { valid: false, reason: 'Path is not a directory' };\n  }\n\n  // Check if writable\n  try {\n    const testPath = path.join(archivePath, '.write-test');\n    const { writeFileSync, unlinkSync } = require('fs');\n    writeFileSync(testPath, '');\n    unlinkSync(testPath);\n    return { valid: true };\n  } catch {\n    return { valid: false, reason: 'Directory is not writable' };\n  }\n}\n"],"names":["detectArchiveType","archivePath","existsSync","stats","statSync","fileSize","hasEmbeddingsDb","path","hasArchiveConfig","conversationCount","countConversations","hasConversationsJson","hasDatedFolders","checkForDatedFolders","countOpenAIConversations","dirPath","entries","readdirSync","datePattern","entry","fullPath","conversationsPath","readFile","content","data"],"mappings":";;AAkBA,eAAsBA,EAAkBC,GAAsD;AAC5F,MAAI,CAACC,EAAWD,CAAW;AACzB,WAAO;AAAA,MACL,MAAM;AAAA,MACN,iBAAiB;AAAA,MACjB,aAAa;AAAA,MACb,MAAMA;AAAA,IAAA;AAIV,QAAME,IAAQC,EAASH,CAAW;AAGlC,MAAIE,EAAM,YAAYF,EAAY,cAAc,SAAS,MAAM,GAAG;AAChE,UAAMI,IAAWF,EAAM;AACvB,WAAO;AAAA,MACL,MAAM;AAAA,MACN,iBAAiB;AAAA,MACjB,aAAa;AAAA,MACb,MAAMF;AAAA,MACN,eAAeI;AAAA,IAAA;AAAA,EAEnB;AAGA,MAAIF,EAAM,eAAe;AAEvB,UAAMG,IAAkBJ,EAAWK,EAAK,KAAKN,GAAa,gBAAgB,CAAC,GACrEO,IAAmBN,EAAWK,EAAK,KAAKN,GAAa,qBAAqB,CAAC;AAEjF,QAAIK,KAAmBE,GAAkB;AAEvC,YAAMC,IAAoBC,EAAmBT,CAAW;AACxD,aAAO;AAAA,QACL,MAAM;AAAA,QACN,iBAAiB;AAAA,QACjB,aAAa;AAAA,QACb,MAAMA;AAAA,QACN,mBAAAQ;AAAA,MAAA;AAAA,IAEJ;AAGA,UAAME,IAAuBT,EAAWK,EAAK,KAAKN,GAAa,oBAAoB,CAAC,GAC9EW,IAAkBC,EAAqBZ,CAAW;AAExD,QAAIU,KAAwBC,GAAiB;AAC3C,YAAMH,IAAoB,MAAMK,EAAyBb,CAAW;AACpE,aAAO;AAAA,QACL,MAAM;AAAA,QACN,iBAAiB;AAAA,QACjB,aAAa;AAAA,QACb,MAAMA;AAAA,QACN,mBAAAQ;AAAA,MAAA;AAAA,IAEJ;AAAA,EACF;AAEA,SAAO;AAAA,IACL,MAAM;AAAA,IACN,iBAAiB;AAAA,IACjB,aAAa;AAAA,IACb,MAAMR;AAAA,EAAA;AAEV;AAKA,SAASY,EAAqBE,GAA0B;AACtD,MAAI;AACF,UAAMC,IAAUC,EAAYF,CAAO,GAC7BG,IAAc;AACpB,WAAOF,EAAQ,KAAK,CAAAG,MAASD,EAAY,KAAKC,CAAK,CAAC;AAAA,EACtD,QAAQ;AACN,WAAO;AAAA,EACT;AACF;AAKA,SAAST,EAAmBT,GAA6B;AACvD,MAAI;AAGF,WAFgBgB,EAAYhB,CAAW,EAExB,OAAO,CAAAkB,MAAS;AAC7B,YAAMC,IAAWb,EAAK,KAAKN,GAAakB,CAAK;AAC7C,aAAOf,EAASgB,CAAQ,EAAE,YAAA,KAAiB,CAACD,EAAM,WAAW,GAAG;AAAA,IAClE,CAAC,EAAE;AAAA,EACL,QAAQ;AACN,WAAO;AAAA,EACT;AACF;AAKA,eAAeL,EAAyBC,GAAkC;AACxE,QAAMM,IAAoBd,EAAK,KAAKQ,GAAS,oBAAoB;AAEjE,MAAIb,EAAWmB,CAAiB;AAC9B,QAAI;AACF,YAAM,EAAE,UAAAC,EAAA,IAAa,MAAM,OAAO,kBAAkB,GAC9CC,IAAU,MAAMD,EAASD,GAAmB,OAAO,GACnDG,IAAO,KAAK,MAAMD,CAAO;AAC/B,aAAO,MAAM,QAAQC,CAAI,IAAIA,EAAK,SAAS;AAAA,IAC7C,QAAQ;AACN,aAAO;AAAA,IACT;AAIF,MAAI;AACF,UAAMR,IAAUC,EAAYF,CAAO,GAC7BG,IAAc;AACpB,WAAOF,EAAQ,OAAO,CAAAG,MAASD,EAAY,KAAKC,CAAK,CAAC,EAAE;AAAA,EAC1D,QAAQ;AACN,WAAO;AAAA,EACT;AACF;"}