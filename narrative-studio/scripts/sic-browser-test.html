<!DOCTYPE html>
<html>
<head>
  <title>SIC vs Lite Comparative Test</title>
  <style>
    body { font-family: monospace; padding: 20px; max-width: 1200px; margin: 0 auto; background: #1a1a2e; color: #eee; }
    .results { white-space: pre-wrap; background: #16213e; padding: 15px; border-radius: 8px; margin: 10px 0; max-height: 500px; overflow-y: auto; }
    button { background: #0f3460; color: white; border: none; padding: 10px 20px; cursor: pointer; margin: 5px; border-radius: 4px; }
    button:hover { background: #1a5276; }
    button:disabled { background: #444; cursor: not-allowed; }
    .progress { background: #16213e; padding: 10px; border-radius: 4px; margin: 10px 0; }
    .error { color: #e74c3c; }
    .success { color: #2ecc71; }
    h1 { color: #e94560; }
    h2 { color: #0f4c75; }
    .summary { background: #0f3460; padding: 15px; border-radius: 8px; margin: 20px 0; }
    table { width: 100%; border-collapse: collapse; }
    th, td { padding: 8px; text-align: left; border-bottom: 1px solid #333; }
    th { background: #16213e; }
  </style>
</head>
<body>
  <h1>SIC vs Traditional AI Detection</h1>
  <p>This test compares SIC (Subjective Intentional Constraint) analysis against the Lite heuristic detector.</p>

  <div>
    <button onclick="runTest(10)">Quick Test (10 samples)</button>
    <button onclick="runTest(25)">Medium Test (25 samples)</button>
    <button onclick="runTest(50)">Full Test (50 samples)</button>
    <button onclick="stopTest()" id="stopBtn" disabled>Stop Test</button>
  </div>

  <div class="progress" id="progress">Ready to run...</div>

  <div class="summary" id="summary" style="display:none;">
    <h2>Results Summary</h2>
    <table>
      <tr><th>Metric</th><th>SIC</th><th>Lite</th></tr>
      <tr><td>AI texts correct</td><td id="sicAi">-</td><td id="liteAi">-</td></tr>
      <tr><td>Human texts correct</td><td id="sicHuman">-</td><td id="liteHuman">-</td></tr>
      <tr><td>Overall accuracy</td><td id="sicTotal">-</td><td id="liteTotal">-</td></tr>
    </table>
  </div>

  <h2>Log</h2>
  <div class="results" id="log"></div>

  <script>
    const ARCHIVE_URL = 'http://localhost:3002';
    const API_URL = 'https://npe-api.tem-527.workers.dev';

    let running = false;
    let results = [];

    function log(msg, isError = false) {
      const logEl = document.getElementById('log');
      const line = document.createElement('div');
      line.textContent = `[${new Date().toLocaleTimeString()}] ${msg}`;
      if (isError) line.className = 'error';
      logEl.appendChild(line);
      logEl.scrollTop = logEl.scrollHeight;
    }

    function updateProgress(msg) {
      document.getElementById('progress').textContent = msg;
    }

    function getAuthToken() {
      return localStorage.getItem('narrative-studio-auth-token') ||
             localStorage.getItem('post-social:token');
    }

    function getAuthHeaders() {
      const token = getAuthToken();
      return {
        'Content-Type': 'application/json',
        ...(token ? { Authorization: `Bearer ${token}` } : {}),
      };
    }

    async function fetchConversations(limit) {
      const res = await fetch(`${ARCHIVE_URL}/api/conversations?limit=${limit}`);
      const data = await res.json();
      return data.conversations || [];
    }

    async function fetchMessages(folder) {
      const res = await fetch(`${ARCHIVE_URL}/api/conversations/${encodeURIComponent(folder)}`);
      if (!res.ok) throw new Error(`HTTP ${res.status}`);
      const data = await res.json();
      return data.messages || [];
    }

    async function runSIC(text) {
      const res = await fetch(`${API_URL}/ai-detection/sic/sic`, {
        method: 'POST',
        headers: getAuthHeaders(),
        body: JSON.stringify({ text }),
      });
      return res.json();
    }

    async function runLite(text) {
      const res = await fetch(`${API_URL}/ai-detection/lite`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ text, useLLMJudge: false }),
      });
      return res.json();
    }

    function extractTexts(messages, role, maxCount) {
      const targetRole = role === 'ai' ? 'assistant' : 'user';
      const samples = [];

      for (const msg of messages) {
        if (msg.role !== targetRole) continue;
        if (!msg.content || typeof msg.content !== 'string') continue;

        const text = msg.content.trim();
        const words = text.split(/\s+/).filter(w => w.length > 0);

        if (words.length < 50) continue;

        // Truncate to ~2000 words
        const truncated = words.length > 2000 ? words.slice(0, 2000).join(' ') : text;
        samples.push({ id: msg.id, text: truncated });

        if (samples.length >= maxCount) break;
      }

      return samples;
    }

    async function collectCorpus(targetCount) {
      log(`Collecting ${targetCount} AI texts and ${targetCount} human texts...`);

      const aiTexts = [];
      const humanTexts = [];

      const convs = await fetchConversations(200);
      log(`Found ${convs.length} conversations`);

      // Sort by date (oldest first for more human content)
      convs.sort((a, b) => (a.created_at || 0) - (b.created_at || 0));

      for (const conv of convs) {
        if (!running) break;
        if (aiTexts.length >= targetCount && humanTexts.length >= targetCount) break;
        if (!conv.folder) continue;

        try {
          const messages = await fetchMessages(conv.folder);

          if (aiTexts.length < targetCount) {
            const ai = extractTexts(messages, 'ai', targetCount - aiTexts.length);
            aiTexts.push(...ai);
          }

          if (humanTexts.length < targetCount) {
            const human = extractTexts(messages, 'human', targetCount - humanTexts.length);
            humanTexts.push(...human);
          }

          updateProgress(`Collecting: AI ${aiTexts.length}/${targetCount}, Human ${humanTexts.length}/${targetCount}`);
        } catch (e) {
          // Skip problematic conversations
        }
      }

      return { aiTexts, humanTexts };
    }

    async function runTest(targetCount) {
      if (running) return;
      running = true;
      results = [];

      document.getElementById('stopBtn').disabled = false;
      document.getElementById('log').innerHTML = '';
      document.getElementById('summary').style.display = 'none';

      const token = getAuthToken();
      log(`Auth token: ${token ? 'Found' : 'Not found (SIC may fail)'}`);

      try {
        const { aiTexts, humanTexts } = await collectCorpus(targetCount);
        log(`Corpus: ${aiTexts.length} AI texts, ${humanTexts.length} human texts`);

        if (aiTexts.length < 5 || humanTexts.length < 5) {
          log('Not enough samples!', true);
          running = false;
          return;
        }

        // Test AI texts
        log('Testing AI texts...');
        for (let i = 0; i < aiTexts.length && running; i++) {
          const sample = aiTexts[i];
          updateProgress(`Testing AI text ${i + 1}/${aiTexts.length}`);

          const result = { source: 'ai', sic: null, lite: null };

          try {
            const sicResult = await runSIC(sample.text);
            if (sicResult.error) {
              result.sic = { error: sicResult.error };
            } else {
              result.sic = {
                aiProbability: sicResult.aiProbability,
                sicScore: sicResult.sicScore,
                correct: sicResult.aiProbability >= 0.5,
              };
            }
          } catch (e) {
            result.sic = { error: e.message };
          }

          try {
            const liteResult = await runLite(sample.text);
            result.lite = {
              ai_likelihood: liteResult.ai_likelihood,
              correct: liteResult.ai_likelihood >= 0.5,
            };
          } catch (e) {
            result.lite = { error: e.message };
          }

          results.push(result);
          const sicMark = result.sic?.correct ? '✓' : result.sic?.error ? '!' : '✗';
          const liteMark = result.lite?.correct ? '✓' : '✗';
          log(`[${i + 1}] AI: SIC ${sicMark} (${result.sic?.aiProbability?.toFixed(2) || 'err'}) | Lite ${liteMark} (${result.lite?.ai_likelihood?.toFixed(2) || 'err'})`);

          await new Promise(r => setTimeout(r, 300));
        }

        // Test human texts
        log('Testing human texts...');
        for (let i = 0; i < humanTexts.length && running; i++) {
          const sample = humanTexts[i];
          updateProgress(`Testing human text ${i + 1}/${humanTexts.length}`);

          const result = { source: 'human', sic: null, lite: null };

          try {
            const sicResult = await runSIC(sample.text);
            if (sicResult.error) {
              result.sic = { error: sicResult.error };
            } else {
              result.sic = {
                aiProbability: sicResult.aiProbability,
                sicScore: sicResult.sicScore,
                correct: sicResult.aiProbability < 0.5,
              };
            }
          } catch (e) {
            result.sic = { error: e.message };
          }

          try {
            const liteResult = await runLite(sample.text);
            result.lite = {
              ai_likelihood: liteResult.ai_likelihood,
              correct: liteResult.ai_likelihood < 0.5,
            };
          } catch (e) {
            result.lite = { error: e.message };
          }

          results.push(result);
          const sicMark = result.sic?.correct ? '✓' : result.sic?.error ? '!' : '✗';
          const liteMark = result.lite?.correct ? '✓' : '✗';
          log(`[${i + 1}] Human: SIC ${sicMark} (${result.sic?.aiProbability?.toFixed(2) || 'err'}) | Lite ${liteMark} (${result.lite?.ai_likelihood?.toFixed(2) || 'err'})`);

          await new Promise(r => setTimeout(r, 300));
        }

        // Calculate summary
        const aiResults = results.filter(r => r.source === 'ai');
        const humanResults = results.filter(r => r.source === 'human');

        const sicAiCorrect = aiResults.filter(r => r.sic?.correct).length;
        const sicHumanCorrect = humanResults.filter(r => r.sic?.correct).length;
        const liteAiCorrect = aiResults.filter(r => r.lite?.correct).length;
        const liteHumanCorrect = humanResults.filter(r => r.lite?.correct).length;

        document.getElementById('sicAi').textContent = `${sicAiCorrect}/${aiResults.length} (${(100 * sicAiCorrect / aiResults.length).toFixed(1)}%)`;
        document.getElementById('sicHuman').textContent = `${sicHumanCorrect}/${humanResults.length} (${(100 * sicHumanCorrect / humanResults.length).toFixed(1)}%)`;
        document.getElementById('sicTotal').textContent = `${sicAiCorrect + sicHumanCorrect}/${results.length} (${(100 * (sicAiCorrect + sicHumanCorrect) / results.length).toFixed(1)}%)`;

        document.getElementById('liteAi').textContent = `${liteAiCorrect}/${aiResults.length} (${(100 * liteAiCorrect / aiResults.length).toFixed(1)}%)`;
        document.getElementById('liteHuman').textContent = `${liteHumanCorrect}/${humanResults.length} (${(100 * liteHumanCorrect / humanResults.length).toFixed(1)}%)`;
        document.getElementById('liteTotal').textContent = `${liteAiCorrect + liteHumanCorrect}/${results.length} (${(100 * (liteAiCorrect + liteHumanCorrect) / results.length).toFixed(1)}%)`;

        document.getElementById('summary').style.display = 'block';

        log('='.repeat(50));
        log('TEST COMPLETE');
        log(`SIC: AI ${sicAiCorrect}/${aiResults.length}, Human ${sicHumanCorrect}/${humanResults.length}, Total ${(100 * (sicAiCorrect + sicHumanCorrect) / results.length).toFixed(1)}%`);
        log(`Lite: AI ${liteAiCorrect}/${aiResults.length}, Human ${liteHumanCorrect}/${humanResults.length}, Total ${(100 * (liteAiCorrect + liteHumanCorrect) / results.length).toFixed(1)}%`);

      } catch (e) {
        log(`Error: ${e.message}`, true);
      }

      running = false;
      document.getElementById('stopBtn').disabled = true;
      updateProgress('Complete');
    }

    function stopTest() {
      running = false;
      log('Test stopped by user');
    }
  </script>
</body>
</html>
