/**
 * Unified AUI Service - Book & Artifact Methods
 *
 * Book creation, provenance tracking, and artifact export operations.
 *
 * @module @humanizer/core/aui/service/books
 */

import type {
  Book,
  BookChapter,
  BookFromClusterOptions,
  HarvestOptions,
  HarvestResult,
  GenerateArcOptions,
  NarrativeArc,
  ContentCluster,
} from '../types.js';
import type {
  PersonaProfile,
  StyleProfile,
  AuiArtifact,
  CreateArtifactOptions,
} from '../../storage/aui-postgres-store.js';
import type { ContentBuffer, ProvenanceChain, BufferOperation } from '../../buffer/types.js';
import { getBuilderAgent, mergePersonaWithStyle, type PersonaProfileForRewrite } from '../../houses/builder.js';
import type { ServiceDependencies } from './types.js';
import type { ClusteringMethods } from './archive-clustering.js';

// ═══════════════════════════════════════════════════════════════════════════
// BOOK CREATION METHODS
// ═══════════════════════════════════════════════════════════════════════════

export interface BookMethods {
  createBookFromCluster(clusterId: string, options?: BookFromClusterOptions): Promise<Book>;
  createBookWithPersona(options: {
    userId: string;
    clusterId?: string;
    query?: string;
    personaId?: string;
    styleId?: string;
    title?: string;
    arcType?: 'chronological' | 'thematic' | 'dramatic' | 'exploratory';
    maxPassages?: number;
    onProgress?: (progress: { phase: string; step: number; totalSteps: number; message: string }) => void;
    embedFn?: (text: string) => Promise<number[]>;
  }): Promise<Book>;
  harvest(options: HarvestOptions): Promise<HarvestResult>;
  generateArc(options: GenerateArcOptions): Promise<NarrativeArc>;
  listBooks(options?: { userId?: string; limit?: number }): Promise<Book[]>;
  getBook(bookId: string): Promise<Book | undefined>;
}

export function createBookMethods(
  deps: ServiceDependencies,
  clusteringMethods: ClusteringMethods
): BookMethods {
  // HTML escape helper
  function escapeHtml(text: string): string {
    return text
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#039;');
  }

  // Book to markdown
  function bookToMarkdown(book: Book): string {
    const lines: string[] = [];
    lines.push(`# ${book.title}`);
    lines.push('');

    if (book.description) {
      lines.push(`*${book.description}*`);
      lines.push('');
    }

    if (book.arc?.introduction) {
      lines.push('## Introduction');
      lines.push('');
      lines.push(book.arc.introduction);
      lines.push('');
    }

    for (const chapter of book.chapters) {
      lines.push(`## ${chapter.title}`);
      lines.push('');
      lines.push(chapter.content);
      lines.push('');
    }

    lines.push('---');
    lines.push('');
    lines.push(`*Generated by humanizer.com*`);
    lines.push(`*Created: ${book.createdAt.toISOString()}*`);

    return lines.join('\n');
  }

  // Book to HTML
  function bookToHtml(book: Book): string {
    const lines: string[] = [];

    lines.push('<!DOCTYPE html>');
    lines.push('<html lang="en">');
    lines.push('<head>');
    lines.push(`  <meta charset="UTF-8">`);
    lines.push(`  <meta name="viewport" content="width=device-width, initial-scale=1.0">`);
    lines.push(`  <title>${escapeHtml(book.title)}</title>`);
    lines.push('  <style>');
    lines.push(
      '    body { font-family: Georgia, serif; max-width: 800px; margin: 0 auto; padding: 2rem; line-height: 1.6; }'
    );
    lines.push('    h1 { border-bottom: 2px solid #333; padding-bottom: 0.5rem; }');
    lines.push('    h2 { color: #444; margin-top: 2rem; }');
    lines.push('    .intro { font-style: italic; color: #666; }');
    lines.push('    .chapter { margin-bottom: 2rem; }');
    lines.push(
      '    .footer { margin-top: 3rem; padding-top: 1rem; border-top: 1px solid #ccc; font-size: 0.9rem; color: #888; }'
    );
    lines.push('  </style>');
    lines.push('</head>');
    lines.push('<body>');

    lines.push(`  <h1>${escapeHtml(book.title)}</h1>`);

    if (book.description) {
      lines.push(`  <p class="intro">${escapeHtml(book.description)}</p>`);
    }

    if (book.arc?.introduction) {
      lines.push('  <section class="introduction">');
      lines.push('    <h2>Introduction</h2>');
      lines.push(`    <p>${escapeHtml(book.arc.introduction)}</p>`);
      lines.push('  </section>');
    }

    for (const chapter of book.chapters) {
      lines.push('  <section class="chapter">');
      lines.push(`    <h2>${escapeHtml(chapter.title)}</h2>`);
      const paragraphs = chapter.content.split('\n\n').filter(Boolean);
      for (const para of paragraphs) {
        lines.push(`    <p>${escapeHtml(para)}</p>`);
      }
      lines.push('  </section>');
    }

    lines.push('  <div class="footer">');
    lines.push('    <p>Generated by humanizer.com</p>');
    lines.push(`    <p>Created: ${book.createdAt.toISOString()}</p>`);
    lines.push('  </div>');

    lines.push('</body>');
    lines.push('</html>');

    return lines.join('\n');
  }

  // Index book content
  async function indexBookContent(
    book: Book,
    embedFn?: (text: string) => Promise<number[]>
  ): Promise<void> {
    const booksStore = deps.getBooksStore();
    if (!booksStore || !booksStore.isAvailable()) {
      return;
    }

    let position = 0;

    for (const chapter of book.chapters) {
      const node = await booksStore.createNode({
        bookId: book.id,
        chapterId: chapter.id,
        text: chapter.content,
        format: 'markdown',
        position: position++,
        hierarchyLevel: 0,
        sourceType: 'synthesized',
        metadata: {
          chapterTitle: chapter.title,
          passageIds: chapter.passageIds,
          wordCount: chapter.wordCount,
        },
      });

      if (embedFn) {
        try {
          const embedding = await embedFn(chapter.content);
          await booksStore.updateNodeEmbedding(
            node.id,
            embedding,
            deps.getDefaultEmbeddingModel(),
            node.contentHash
          );
        } catch (error) {
          console.warn(`Failed to embed chapter ${chapter.title}:`, error);
        }
      }
    }

    if (book.arc?.introduction && embedFn) {
      try {
        const apexNode = await booksStore.createNode({
          bookId: book.id,
          text: book.arc.introduction,
          format: 'markdown',
          position: 0,
          hierarchyLevel: 2,
          sourceType: 'synthesized',
          metadata: {
            bookTitle: book.title,
            arcType: book.arc.arcType,
            themes: book.arc.themes,
          },
        });

        const apexEmbedding = await embedFn(book.arc.introduction);
        await booksStore.updateNodeEmbedding(
          apexNode.id,
          apexEmbedding,
          deps.getDefaultEmbeddingModel(),
          apexNode.contentHash
        );
      } catch (error) {
        console.warn('Failed to create/embed apex node:', error);
      }
    }
  }

  const methods: BookMethods = {
    async createBookFromCluster(
      clusterId: string,
      options?: BookFromClusterOptions
    ): Promise<Book> {
      const cluster = await clusteringMethods.getCluster(clusterId);
      if (!cluster) {
        throw new Error(`Cluster "${clusterId}" not found`);
      }

      const store = deps.getStore();
      let persona: PersonaProfile | undefined;
      let style: StyleProfile | undefined;
      let personaForRewrite: PersonaProfileForRewrite | undefined;

      if (options?.personaId && store) {
        persona = await store.getPersonaProfile(options.personaId);
        if (!persona) {
          console.warn(`Persona "${options.personaId}" not found, proceeding without persona`);
        }
      } else if (options?.useDefaultPersona !== false && options?.userId && store) {
        persona = await store.getDefaultPersonaProfile(options.userId);
      }

      if (persona && store) {
        if (options?.styleId) {
          style = await store.getStyleProfile(options.styleId);
        } else {
          style = await store.getDefaultStyleProfile(persona.id);
        }
        personaForRewrite = mergePersonaWithStyle(persona, style);
      }

      const hasPersona = !!personaForRewrite;
      const booksStore = deps.getBooksStore();
      const hasIndexing = booksStore?.isAvailable() ?? false;
      const totalSteps = 4 + (hasPersona ? 1 : 0) + (hasIndexing ? 1 : 0);

      if (options?.onProgress) {
        options.onProgress({
          phase: 'gathering',
          step: 1,
          totalSteps,
          message: 'Gathering passages...',
        });
      }

      const maxPassages = options?.maxPassages || 50;
      const passages = cluster.passages.slice(0, maxPassages);

      const harvestedPassages = passages.map(p => ({
        id: p.id,
        text: p.text,
        relevance: 1 - p.distanceFromCentroid,
        sourceType: p.sourceType,
        authorRole: p.authorRole,
        title: p.title,
        sourceCreatedAt: p.sourceCreatedAt,
        wordCount: p.wordCount,
      }));

      if (options?.onProgress) {
        options.onProgress({
          phase: 'generating_arc',
          step: 2,
          totalSteps,
          message: 'Generating narrative arc...',
        });
      }

      const arc = await methods.generateArc({
        passages: harvestedPassages,
        arcType: options?.arcType || 'thematic',
        introWordCount: 300,
      });

      if (options?.onProgress) {
        options.onProgress({
          phase: 'assembling',
          step: 3,
          totalSteps,
          message: 'Assembling book...',
        });
      }

      let chapters = arc.chapters.map((ch, idx) => {
        const chapterPassages = harvestedPassages.filter(p => ch.passageIds.includes(p.id));
        const content = chapterPassages.map(p => p.text).join('\n\n---\n\n');

        return {
          id: `chapter-${idx + 1}`,
          title: ch.title,
          content,
          passageIds: ch.passageIds,
          position: idx,
          wordCount: content.split(/\s+/).filter(Boolean).length,
        };
      });

      let currentStep = 4;
      if (personaForRewrite) {
        if (options?.onProgress) {
          options.onProgress({
            phase: 'persona_rewriting',
            step: currentStep,
            totalSteps,
            message: `Applying ${persona!.name} voice to ${chapters.length} chapters...`,
          });
        }

        const builder = getBuilderAgent();

        chapters = await Promise.all(
          chapters.map(async chapter => {
            const result = await builder.rewriteForPersonaWithRetry(
              {
                text: chapter.content,
                persona: personaForRewrite,
                sourceType: 'book-chapter',
              },
              { maxPasses: 3 }
            );

            return {
              ...chapter,
              content: result.rewritten,
              wordCount: result.rewritten.split(/\s+/).filter(Boolean).length,
            };
          })
        );

        currentStep++;
      }

      const book: Book = {
        id: `book-${Date.now()}`,
        title: options?.title || arc.title,
        description: cluster.description,
        arc,
        chapters,
        sourceClusterId: clusterId,
        createdAt: new Date(),
        updatedAt: new Date(),
        status: 'draft',
        metadata: {
          passageCount: passages.length,
          totalWordCount: chapters.reduce((sum, ch) => sum + ch.wordCount, 0),
          arcType: options?.arcType || 'thematic',
          personaId: persona?.id,
          personaName: persona?.name,
          styleId: style?.id,
          styleName: style?.name,
        },
      };

      if (store) {
        try {
          const storedBook = await store.createBook(book);
          book.id = storedBook.id;
        } catch (error) {
          console.warn('Failed to persist book to store:', error);
        }
      }

      deps.getBooks().set(book.id, book);

      if (booksStore && booksStore.isAvailable()) {
        if (options?.onProgress) {
          options.onProgress({
            phase: 'indexing',
            step: currentStep,
            totalSteps,
            message: 'Indexing book content for search...',
          });
        }
        currentStep++;

        try {
          await indexBookContent(book, options?.embedFn);
        } catch (error) {
          console.warn('Failed to index book content:', error);
        }
      }

      if (options?.onProgress) {
        options.onProgress({
          phase: 'complete',
          step: totalSteps,
          totalSteps,
          message: 'Book created',
        });
      }

      return book;
    },

    async createBookWithPersona(options: {
      userId: string;
      clusterId?: string;
      query?: string;
      personaId?: string;
      styleId?: string;
      title?: string;
      arcType?: 'chronological' | 'thematic' | 'dramatic' | 'exploratory';
      maxPassages?: number;
      onProgress?: (progress: {
        phase: string;
        step: number;
        totalSteps: number;
        message: string;
      }) => void;
      embedFn?: (text: string) => Promise<number[]>;
    }): Promise<Book> {
      if (!options.clusterId && !options.query) {
        throw new Error('Either clusterId or query is required');
      }

      const store = deps.getStore();
      let personaId = options.personaId;
      if (!personaId && store) {
        const defaultPersona = await store.getDefaultPersonaProfile(options.userId);
        if (defaultPersona) {
          personaId = defaultPersona.id;
        }
      }

      if (!personaId) {
        throw new Error('No persona specified and no default persona set. Create a persona first.');
      }

      let clusterId = options.clusterId;
      if (!clusterId && options.query) {
        const harvestResult = await methods.harvest({
          query: options.query,
          limit: options.maxPassages ?? 50,
        });

        if (harvestResult.passages.length === 0) {
          throw new Error(`No passages found for query: "${options.query}"`);
        }

        const clusterPassages = harvestResult.passages.map(p => ({
          id: p.id,
          text: p.text,
          sourceType: p.sourceType ?? 'unknown',
          authorRole: 'author' as const,
          distanceFromCentroid: 1 - (p.relevance ?? 0.5),
          wordCount: p.wordCount ?? p.text.split(/\s+/).filter(Boolean).length,
        }));

        const totalWords = clusterPassages.reduce((sum, p) => sum + p.wordCount, 0);
        const avgWordCount =
          clusterPassages.length > 0 ? Math.round(totalWords / clusterPassages.length) : 0;

        const tempCluster: ContentCluster = {
          id: `cluster-${Date.now()}`,
          label: options.title ?? `From: ${options.query}`,
          description: `Harvested from query: ${options.query}`,
          passages: clusterPassages,
          totalPassages: harvestResult.passages.length,
          coherence: 0.7,
          keywords: options.query!.split(/\s+/).filter(w => w.length > 3),
          sourceDistribution: {},
          dateRange: {
            earliest: null,
            latest: null,
          },
          avgWordCount,
        };

        const savedCluster = await clusteringMethods.saveCluster(tempCluster, options.userId);
        clusterId = savedCluster.id;
      }

      return methods.createBookFromCluster(clusterId!, {
        title: options.title,
        personaId,
        styleId: options.styleId,
        userId: options.userId,
        useDefaultPersona: false,
        arcType: options.arcType,
        maxPassages: options.maxPassages,
        onProgress: options.onProgress as BookFromClusterOptions['onProgress'],
        embedFn: options.embedFn,
      });
    },

    async harvest(options: HarvestOptions): Promise<HarvestResult> {
      const startTime = Date.now();
      const agenticSearch = deps.getAgenticSearch();

      if (!agenticSearch) {
        throw new Error('Agentic search not configured');
      }

      const searchResults = await agenticSearch.search(options.query, {
        limit: options.limit || 50,
        target: 'archive',
        threshold: options.minRelevance || 0.5,
      });

      let passages = searchResults.results.map(r => ({
        id: r.id,
        text: r.text,
        relevance: r.score,
        sourceType: r.source || 'unknown',
        authorRole: (r as any).authorRole,
        title: (r as any).title,
        sourceCreatedAt: (r as any).sourceCreatedAt
          ? new Date((r as any).sourceCreatedAt)
          : undefined,
        wordCount: r.text.split(/\s+/).filter(Boolean).length,
      }));

      if (options.excludeIds?.length) {
        passages = passages.filter(p => !options.excludeIds!.includes(p.id));
      }

      if (options.dateRange) {
        passages = passages.filter(p => {
          if (!p.sourceCreatedAt) return false;
          if (options.dateRange!.start && p.sourceCreatedAt < options.dateRange!.start)
            return false;
          if (options.dateRange!.end && p.sourceCreatedAt > options.dateRange!.end) return false;
          return true;
        });
      }

      if (options.maxFromSingleSource) {
        const bySource = new Map<string, typeof passages>();
        for (const p of passages) {
          const sourcePassages = bySource.get(p.sourceType) || [];
          bySource.set(p.sourceType, [...sourcePassages, p]);
        }

        passages = [];
        for (const sourcePassages of bySource.values()) {
          passages.push(...sourcePassages.slice(0, options.maxFromSingleSource));
        }
        passages.sort((a, b) => b.relevance - a.relevance);
      }

      return {
        passages,
        query: options.query,
        candidatesFound: searchResults.results.length,
        durationMs: Date.now() - startTime,
      };
    },

    async generateArc(options: GenerateArcOptions): Promise<NarrativeArc> {
      const { passages, arcType = 'thematic' } = options;

      let organizedPassages = [...passages];

      switch (arcType) {
        case 'chronological':
          organizedPassages.sort((a, b) => {
            const dateA = a.sourceCreatedAt?.getTime() || 0;
            const dateB = b.sourceCreatedAt?.getTime() || 0;
            return dateA - dateB;
          });
          break;
        case 'thematic':
          organizedPassages.sort((a, b) => {
            if (a.sourceType !== b.sourceType) {
              return a.sourceType.localeCompare(b.sourceType);
            }
            return b.relevance - a.relevance;
          });
          break;
        case 'dramatic':
          organizedPassages.sort((a, b) => a.relevance - b.relevance);
          break;
        case 'exploratory':
          organizedPassages = organizedPassages.sort(() => Math.random() - 0.5);
          break;
      }

      const chapterCount = Math.min(5, Math.max(3, Math.ceil(passages.length / 10)));
      const passagesPerChapter = Math.ceil(passages.length / chapterCount);

      const chapters: NarrativeArc['chapters'] = [];
      for (let i = 0; i < chapterCount; i++) {
        const chapterPassages = organizedPassages.slice(
          i * passagesPerChapter,
          (i + 1) * passagesPerChapter
        );

        if (chapterPassages.length === 0) continue;

        const firstWords = chapterPassages[0].text.split(/\s+/).slice(0, 5).join(' ');

        chapters.push({
          title: `Chapter ${i + 1}: ${firstWords}...`,
          summary: chapterPassages
            .slice(0, 2)
            .map(p => p.text.substring(0, 100))
            .join(' | '),
          passageIds: chapterPassages.map(p => p.id),
          theme: `Theme ${i + 1}`,
          position: i,
        });
      }

      const allText = passages.map(p => p.text).join(' ');
      const words = allText.toLowerCase().split(/\s+/).filter(w => w.length > 5);
      const wordFreq = new Map<string, number>();
      for (const word of words) {
        wordFreq.set(word, (wordFreq.get(word) || 0) + 1);
      }
      const themes = [...wordFreq.entries()]
        .sort((a, b) => b[1] - a[1])
        .slice(0, 5)
        .map(([word]) => word);

      const transitions = chapters
        .slice(0, -1)
        .map((_, i) => `Transition from ${chapters[i].title} to ${chapters[i + 1].title}`);

      const title =
        themes.length > 0
          ? `Reflections on ${themes.slice(0, 2).join(' and ')}`
          : 'Collected Thoughts';

      const introduction =
        `This collection brings together ${passages.length} passages exploring ${themes.slice(0, 3).join(', ')}. ` +
        `Organized ${arcType === 'chronological' ? 'chronologically' : 'thematically'}, ` +
        `these reflections span ${chapters.length} chapters, each offering a unique perspective on the journey.`;

      return {
        title,
        arcType,
        introduction,
        chapters,
        themes,
        transitions,
      };
    },

    async listBooks(options?: { userId?: string; limit?: number }): Promise<Book[]> {
      const store = deps.getStore();
      if (store) {
        try {
          const books = await store.listBooks(options);
          for (const book of books) {
            deps.getBooks().set(book.id, book);
          }
          return books;
        } catch (error) {
          console.warn('Failed to list books from store:', error);
        }
      }

      return Array.from(deps.getBooks().values());
    },

    async getBook(bookId: string): Promise<Book | undefined> {
      let book = deps.getBooks().get(bookId);
      if (book) return book;

      const store = deps.getStore();
      if (store) {
        try {
          book = await store.getBook(bookId);
          if (book) {
            deps.getBooks().set(bookId, book);
            return book;
          }
        } catch (error) {
          console.warn('Failed to load book from store:', error);
        }
      }

      return undefined;
    },
  };

  return methods;
}

// ═══════════════════════════════════════════════════════════════════════════
// PROVENANCE METHODS
// ═══════════════════════════════════════════════════════════════════════════

export interface ProvenanceMethods {
  createChapterFromBuffer(
    buffer: ContentBuffer,
    bookId: string,
    options?: { chapterTitle?: string; chapterId?: string; position?: number }
  ): Promise<BookChapter>;
  transformAndCommitToBook(options: {
    text: string;
    bookId: string;
    chapterId: string;
    chapterTitle?: string;
    personaId?: string;
    styleId?: string;
    sourceArchiveNodeId?: string;
    onProgress?: (step: string) => void;
  }): Promise<{
    chapter: BookChapter;
    buffer: ContentBuffer;
    provenance: ProvenanceChain;
  }>;
  getChapterProvenance(bookId: string, chapterId: string): Promise<ProvenanceChain | undefined>;
  traceToArchiveOrigin(buffer: ContentBuffer): Promise<{
    archiveNodeIds: string[];
    transformationCount: number;
    operations: BufferOperation[];
  }>;
}

export function createProvenanceMethods(deps: ServiceDependencies): ProvenanceMethods {
  return {
    async createChapterFromBuffer(
      buffer: ContentBuffer,
      bookId: string,
      options?: { chapterTitle?: string; chapterId?: string; position?: number }
    ): Promise<BookChapter> {
      const bufferSvc = deps.getBufferService();

      const chapter = await bufferSvc.commitToBook(
        buffer,
        bookId,
        options?.chapterId ?? `chapter-${Date.now()}`,
        {
          position: options?.position,
          metadata: options?.chapterTitle ? { chapterTitle: options.chapterTitle } : undefined,
        }
      );

      return chapter;
    },

    async transformAndCommitToBook(options: {
      text: string;
      bookId: string;
      chapterId: string;
      chapterTitle?: string;
      personaId?: string;
      styleId?: string;
      sourceArchiveNodeId?: string;
      onProgress?: (step: string) => void;
    }): Promise<{
      chapter: BookChapter;
      buffer: ContentBuffer;
      provenance: ProvenanceChain;
    }> {
      const bufferSvc = deps.getBufferService();

      options.onProgress?.('Creating buffer from content...');

      let buffer = await bufferSvc.createFromText(options.text, {
        metadata: options.sourceArchiveNodeId
          ? { sourceArchiveNodeId: options.sourceArchiveNodeId }
          : undefined,
      });

      if (options.personaId) {
        options.onProgress?.('Applying persona voice...');
        buffer = await bufferSvc.rewriteForPersona(buffer, options.personaId, options.styleId);
      }

      options.onProgress?.('Committing to book...');

      const chapter = await bufferSvc.commitToBook(buffer, options.bookId, options.chapterId, {
        metadata: options.chapterTitle ? { chapterTitle: options.chapterTitle } : undefined,
      });

      const provenance = bufferSvc.getProvenance(buffer);

      return {
        chapter,
        buffer,
        provenance,
      };
    },

    async getChapterProvenance(
      bookId: string,
      chapterId: string
    ): Promise<ProvenanceChain | undefined> {
      const store = deps.getStore();
      if (!store) return undefined;

      // TODO: Implement chapter→buffer lookup once book schema includes bufferId
      return undefined;
    },

    async traceToArchiveOrigin(buffer: ContentBuffer): Promise<{
      archiveNodeIds: string[];
      transformationCount: number;
      operations: BufferOperation[];
    }> {
      const bufferSvc = deps.getBufferService();
      const provenance = bufferSvc.getProvenance(buffer);

      const archiveNodeIds: string[] = [];
      if (buffer.origin.sourceType === 'archive' && buffer.origin.sourceNodeId) {
        archiveNodeIds.push(buffer.origin.sourceNodeId);
      }

      for (const op of provenance.operations) {
        if (op.type === 'merge' && op.parameters.sourceBufferIds) {
          // Merged buffers may have their own archive origins
        }
      }

      return {
        archiveNodeIds,
        transformationCount: provenance.transformationCount,
        operations: provenance.operations,
      };
    },
  };
}

// ═══════════════════════════════════════════════════════════════════════════
// ARTIFACT METHODS
// ═══════════════════════════════════════════════════════════════════════════

export interface ArtifactMethods {
  exportBook(
    bookId: string,
    format?: 'markdown' | 'html' | 'json'
  ): Promise<AuiArtifact | undefined>;
  downloadArtifact(artifactId: string): Promise<AuiArtifact | undefined>;
  listArtifacts(options?: {
    userId?: string;
    limit?: number;
  }): Promise<Omit<AuiArtifact, 'content' | 'contentBinary'>[]>;
}

export function createArtifactMethods(
  deps: ServiceDependencies,
  bookMethods: BookMethods
): ArtifactMethods {
  function escapeHtml(text: string): string {
    return text
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#039;');
  }

  function bookToMarkdown(book: Book): string {
    const lines: string[] = [];
    lines.push(`# ${book.title}`);
    lines.push('');

    if (book.description) {
      lines.push(`*${book.description}*`);
      lines.push('');
    }

    if (book.arc?.introduction) {
      lines.push('## Introduction');
      lines.push('');
      lines.push(book.arc.introduction);
      lines.push('');
    }

    for (const chapter of book.chapters) {
      lines.push(`## ${chapter.title}`);
      lines.push('');
      lines.push(chapter.content);
      lines.push('');
    }

    lines.push('---');
    lines.push('');
    lines.push(`*Generated by humanizer.com*`);
    lines.push(`*Created: ${book.createdAt.toISOString()}*`);

    return lines.join('\n');
  }

  function bookToHtml(book: Book): string {
    const lines: string[] = [];

    lines.push('<!DOCTYPE html>');
    lines.push('<html lang="en">');
    lines.push('<head>');
    lines.push(`  <meta charset="UTF-8">`);
    lines.push(`  <meta name="viewport" content="width=device-width, initial-scale=1.0">`);
    lines.push(`  <title>${escapeHtml(book.title)}</title>`);
    lines.push('  <style>');
    lines.push(
      '    body { font-family: Georgia, serif; max-width: 800px; margin: 0 auto; padding: 2rem; line-height: 1.6; }'
    );
    lines.push('    h1 { border-bottom: 2px solid #333; padding-bottom: 0.5rem; }');
    lines.push('    h2 { color: #444; margin-top: 2rem; }');
    lines.push('    .intro { font-style: italic; color: #666; }');
    lines.push('    .chapter { margin-bottom: 2rem; }');
    lines.push(
      '    .footer { margin-top: 3rem; padding-top: 1rem; border-top: 1px solid #ccc; font-size: 0.9rem; color: #888; }'
    );
    lines.push('  </style>');
    lines.push('</head>');
    lines.push('<body>');

    lines.push(`  <h1>${escapeHtml(book.title)}</h1>`);

    if (book.description) {
      lines.push(`  <p class="intro">${escapeHtml(book.description)}</p>`);
    }

    if (book.arc?.introduction) {
      lines.push('  <section class="introduction">');
      lines.push('    <h2>Introduction</h2>');
      lines.push(`    <p>${escapeHtml(book.arc.introduction)}</p>`);
      lines.push('  </section>');
    }

    for (const chapter of book.chapters) {
      lines.push('  <section class="chapter">');
      lines.push(`    <h2>${escapeHtml(chapter.title)}</h2>`);
      const paragraphs = chapter.content.split('\n\n').filter(Boolean);
      for (const para of paragraphs) {
        lines.push(`    <p>${escapeHtml(para)}</p>`);
      }
      lines.push('  </section>');
    }

    lines.push('  <div class="footer">');
    lines.push('    <p>Generated by humanizer.com</p>');
    lines.push(`    <p>Created: ${book.createdAt.toISOString()}</p>`);
    lines.push('  </div>');

    lines.push('</body>');
    lines.push('</html>');

    return lines.join('\n');
  }

  return {
    async exportBook(
      bookId: string,
      format: 'markdown' | 'html' | 'json' = 'markdown'
    ): Promise<AuiArtifact | undefined> {
      const store = deps.getStore();
      if (!store) {
        throw new Error('Persistent store not configured - cannot create artifacts');
      }

      const book = await bookMethods.getBook(bookId);
      if (!book) {
        throw new Error(`Book "${bookId}" not found`);
      }

      let content: string;
      let mimeType: string;

      switch (format) {
        case 'markdown':
          content = bookToMarkdown(book);
          mimeType = 'text/markdown';
          break;
        case 'html':
          content = bookToHtml(book);
          mimeType = 'text/html';
          break;
        case 'json':
          content = JSON.stringify(book, null, 2);
          mimeType = 'application/json';
          break;
        default:
          throw new Error(`Unsupported format: ${format}`);
      }

      const artifact = await store.createArtifact({
        name: `${book.title.replace(/[^a-zA-Z0-9]/g, '_')}.${format === 'markdown' ? 'md' : format}`,
        artifactType: format,
        content,
        mimeType,
        sourceType: 'book',
        sourceId: bookId,
        metadata: {
          bookTitle: book.title,
          chapterCount: book.chapters.length,
          wordCount: book.chapters.reduce((sum, ch) => sum + ch.wordCount, 0),
        },
      });

      return artifact;
    },

    async downloadArtifact(artifactId: string): Promise<AuiArtifact | undefined> {
      const store = deps.getStore();
      if (!store) {
        throw new Error('Persistent store not configured');
      }

      return store.exportArtifact(artifactId);
    },

    async listArtifacts(options?: {
      userId?: string;
      limit?: number;
    }): Promise<Omit<AuiArtifact, 'content' | 'contentBinary'>[]> {
      const store = deps.getStore();
      if (!store) {
        return [];
      }

      return store.listArtifacts(options);
    },
  };
}
