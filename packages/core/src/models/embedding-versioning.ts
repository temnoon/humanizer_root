/**
 * Embedding Version Management
 *
 * CRITICAL: Prevents data corruption when switching embedding models.
 *
 * Problem: Embeddings from different models (768-dim vs 1536-dim) cannot be
 * compared directly. Mixing them causes incorrect similarity scores and
 * corrupted search results.
 *
 * Solution: Track model ID with each embedding and prevent cross-model operations.
 *
 * Part of Phase 1: Model Registry & Vetting Enforcement.
 *
 * @module models/embedding-versioning
 */

// ═══════════════════════════════════════════════════════════════════
// CONFIGURATION
// ═══════════════════════════════════════════════════════════════════

/**
 * Configuration for embedding version management
 */
export interface EmbeddingVersionConfig {
  /** Store model ID with each embedding (RECOMMENDED: always true) */
  trackModelWithEmbedding: boolean;

  /** Fail operations that mix embeddings from different models */
  preventCrossModelComparison: boolean;

  /** Automatically trigger re-embedding job when default model changes */
  reembedOnModelChange: boolean;

  /** During model transition, support dual storage (old and new) */
  dualStorageEnabled: boolean;

  /** Days to keep both old and new embeddings during transition */
  transitionPeriodDays: number;

  /** Warn when embedding version is stale (days since creation) */
  staleWarningDays: number;
}

/**
 * Default configuration - strict mode for data integrity
 */
export const DEFAULT_EMBEDDING_VERSION_CONFIG: EmbeddingVersionConfig = {
  trackModelWithEmbedding: true,
  preventCrossModelComparison: true,
  reembedOnModelChange: false, // Manual trigger preferred for control
  dualStorageEnabled: false,
  transitionPeriodDays: 14,
  staleWarningDays: 90,
};

// ═══════════════════════════════════════════════════════════════════
// STORED EMBEDDING
// ═══════════════════════════════════════════════════════════════════

/**
 * An embedding with version metadata
 */
export interface StoredEmbedding {
  /** The embedding vector */
  vector: number[];

  /** Model ID that generated this embedding */
  modelId: string;

  /** Dimensions of the embedding */
  dimensions: number;

  /** When the embedding was created */
  createdAt: Date;

  /** Schema version for the embedding format */
  version: number;

  /** Content hash for deduplication (optional) */
  contentHash?: string;
}

/**
 * Status of an embedding during model transition
 */
export type EmbeddingStatus =
  | 'current'      // Generated by current default model
  | 'stale'        // Generated by previous model, needs re-embedding
  | 'transitioning' // Both old and new embeddings exist
  | 'failed';      // Re-embedding failed

/**
 * Summary of embedding versions in the database
 */
export interface EmbeddingVersionSummary {
  /** Model ID → count of embeddings */
  byModel: Record<string, number>;

  /** Total embeddings */
  total: number;

  /** Current default model ID */
  currentModelId: string;

  /** Count of stale embeddings needing re-embedding */
  staleCount: number;

  /** Oldest embedding date */
  oldestEmbedding?: Date;

  /** Newest embedding date */
  newestEmbedding?: Date;
}

// ═══════════════════════════════════════════════════════════════════
// ERRORS
// ═══════════════════════════════════════════════════════════════════

/**
 * Error thrown when attempting to compare incompatible embeddings
 */
export class EmbeddingIncompatibilityError extends Error {
  constructor(
    public readonly embedding1: { modelId: string; dimensions: number },
    public readonly embedding2: { modelId: string; dimensions: number },
    message?: string
  ) {
    super(
      message ??
        `Cannot compare embeddings from different models: ` +
        `${embedding1.modelId} (${embedding1.dimensions}d) vs ` +
        `${embedding2.modelId} (${embedding2.dimensions}d)`
    );
    this.name = 'EmbeddingIncompatibilityError';
  }
}

/**
 * Error thrown when embeddings are stale and operation requires current
 */
export class StaleEmbeddingError extends Error {
  constructor(
    public readonly modelId: string,
    public readonly currentModelId: string
  ) {
    super(
      `Embedding was created with model "${modelId}" but current model is "${currentModelId}". ` +
      `Re-embedding required.`
    );
    this.name = 'StaleEmbeddingError';
  }
}

// ═══════════════════════════════════════════════════════════════════
// RE-EMBEDDING PROGRESS
// ═══════════════════════════════════════════════════════════════════

/**
 * Progress of a re-embedding job
 */
export interface ReembeddingProgress {
  /** Job ID */
  jobId: string;

  /** Status of the job */
  status: 'pending' | 'running' | 'completed' | 'failed' | 'cancelled';

  /** Total items to re-embed */
  total: number;

  /** Items completed */
  completed: number;

  /** Items remaining */
  remaining: number;

  /** Percentage complete */
  percentComplete: number;

  /** Items that failed */
  failed: number;

  /** When job started */
  startedAt?: Date;

  /** When job completed/failed */
  finishedAt?: Date;

  /** Estimated time remaining in seconds */
  estimatedSecondsRemaining?: number;

  /** Old model being replaced */
  fromModelId: string;

  /** New model being used */
  toModelId: string;
}

// ═══════════════════════════════════════════════════════════════════
// EMBEDDING VERSION MANAGER
// ═══════════════════════════════════════════════════════════════════

/**
 * Manages embedding versions and model transitions
 */
export class EmbeddingVersionManager {
  private config: EmbeddingVersionConfig;
  private currentModelId: string;

  constructor(
    currentModelId: string,
    config: Partial<EmbeddingVersionConfig> = {}
  ) {
    this.currentModelId = currentModelId;
    this.config = { ...DEFAULT_EMBEDDING_VERSION_CONFIG, ...config };
  }

  // ─────────────────────────────────────────────────────────────────
  // Validation
  // ─────────────────────────────────────────────────────────────────

  /**
   * Validate that two embeddings can be compared
   * @throws EmbeddingIncompatibilityError if incompatible
   */
  validateCompatibility(
    embedding1: StoredEmbedding | { modelId: string; dimensions: number },
    embedding2: StoredEmbedding | { modelId: string; dimensions: number }
  ): void {
    if (!this.config.preventCrossModelComparison) {
      return; // Validation disabled
    }

    if (embedding1.modelId !== embedding2.modelId) {
      throw new EmbeddingIncompatibilityError(
        { modelId: embedding1.modelId, dimensions: embedding1.dimensions },
        { modelId: embedding2.modelId, dimensions: embedding2.dimensions }
      );
    }

    if (embedding1.dimensions !== embedding2.dimensions) {
      throw new EmbeddingIncompatibilityError(
        { modelId: embedding1.modelId, dimensions: embedding1.dimensions },
        { modelId: embedding2.modelId, dimensions: embedding2.dimensions },
        `Dimension mismatch: ${embedding1.dimensions} vs ${embedding2.dimensions}`
      );
    }
  }

  /**
   * Check if an embedding is current (matches default model)
   */
  isCurrent(embedding: StoredEmbedding | { modelId: string }): boolean {
    return embedding.modelId === this.currentModelId;
  }

  /**
   * Check if an embedding is stale (doesn't match default model)
   */
  isStale(embedding: StoredEmbedding | { modelId: string }): boolean {
    return embedding.modelId !== this.currentModelId;
  }

  /**
   * Get the status of an embedding
   */
  getStatus(embedding: StoredEmbedding): EmbeddingStatus {
    if (this.isCurrent(embedding)) {
      return 'current';
    }
    return 'stale';
  }

  /**
   * Validate that an embedding is current, throw if stale
   * @throws StaleEmbeddingError if embedding is stale
   */
  requireCurrent(embedding: StoredEmbedding | { modelId: string }): void {
    if (this.isStale(embedding)) {
      throw new StaleEmbeddingError(embedding.modelId, this.currentModelId);
    }
  }

  // ─────────────────────────────────────────────────────────────────
  // Configuration
  // ─────────────────────────────────────────────────────────────────

  /**
   * Get current configuration
   */
  getConfig(): EmbeddingVersionConfig {
    return { ...this.config };
  }

  /**
   * Update configuration
   */
  updateConfig(updates: Partial<EmbeddingVersionConfig>): void {
    this.config = { ...this.config, ...updates };
  }

  /**
   * Get current default model ID
   */
  getCurrentModelId(): string {
    return this.currentModelId;
  }

  /**
   * Set new default model ID (triggers migration awareness)
   */
  setCurrentModelId(modelId: string): { previousModelId: string; migrationRequired: boolean } {
    const previousModelId = this.currentModelId;
    this.currentModelId = modelId;

    return {
      previousModelId,
      migrationRequired: previousModelId !== modelId,
    };
  }

  // ─────────────────────────────────────────────────────────────────
  // Helpers for Stored Embedding Creation
  // ─────────────────────────────────────────────────────────────────

  /**
   * Create a StoredEmbedding with proper metadata
   */
  createStoredEmbedding(
    vector: number[],
    options?: { modelId?: string; contentHash?: string }
  ): StoredEmbedding {
    return {
      vector,
      modelId: options?.modelId ?? this.currentModelId,
      dimensions: vector.length,
      createdAt: new Date(),
      version: 1,
      contentHash: options?.contentHash,
    };
  }

  /**
   * Check if embedding should have a staleness warning
   */
  shouldWarnStale(embedding: StoredEmbedding): boolean {
    if (this.isStale(embedding)) {
      return true; // Wrong model, always warn
    }

    const ageMs = Date.now() - embedding.createdAt.getTime();
    const ageDays = ageMs / (1000 * 60 * 60 * 24);
    return ageDays > this.config.staleWarningDays;
  }

  // ─────────────────────────────────────────────────────────────────
  // Summary and Reporting
  // ─────────────────────────────────────────────────────────────────

  /**
   * Calculate summary from a collection of embeddings
   */
  calculateSummary(embeddings: StoredEmbedding[]): EmbeddingVersionSummary {
    const byModel: Record<string, number> = {};
    let staleCount = 0;
    let oldestDate: Date | undefined;
    let newestDate: Date | undefined;

    for (const emb of embeddings) {
      byModel[emb.modelId] = (byModel[emb.modelId] || 0) + 1;

      if (this.isStale(emb)) {
        staleCount++;
      }

      if (!oldestDate || emb.createdAt < oldestDate) {
        oldestDate = emb.createdAt;
      }
      if (!newestDate || emb.createdAt > newestDate) {
        newestDate = emb.createdAt;
      }
    }

    return {
      byModel,
      total: embeddings.length,
      currentModelId: this.currentModelId,
      staleCount,
      oldestEmbedding: oldestDate,
      newestEmbedding: newestDate,
    };
  }

  /**
   * Format summary as human-readable report
   */
  formatSummaryReport(summary: EmbeddingVersionSummary): string {
    const lines: string[] = [
      `═══ Embedding Version Summary ═══`,
      `Current Model: ${summary.currentModelId}`,
      `Total Embeddings: ${summary.total}`,
      `Stale (need re-embedding): ${summary.staleCount}`,
      ``,
      `By Model:`,
    ];

    for (const [modelId, count] of Object.entries(summary.byModel)) {
      const status = modelId === summary.currentModelId ? '✓ current' : '⚠ stale';
      lines.push(`  ${modelId}: ${count} (${status})`);
    }

    if (summary.oldestEmbedding) {
      lines.push(``);
      lines.push(`Oldest: ${summary.oldestEmbedding.toISOString()}`);
      lines.push(`Newest: ${summary.newestEmbedding?.toISOString()}`);
    }

    lines.push(`══════════════════════════════════`);

    return lines.join('\n');
  }
}

// ═══════════════════════════════════════════════════════════════════
// SINGLETON
// ═══════════════════════════════════════════════════════════════════

let _versionManager: EmbeddingVersionManager | null = null;

/**
 * Get the singleton embedding version manager
 */
export function getEmbeddingVersionManager(currentModelId?: string): EmbeddingVersionManager {
  if (!_versionManager) {
    if (!currentModelId) {
      // Default to nomic for backward compatibility
      currentModelId = 'nomic-embed-text:latest';
    }
    _versionManager = new EmbeddingVersionManager(currentModelId);
  }
  return _versionManager;
}

/**
 * Reset the embedding version manager (for testing)
 */
export function resetEmbeddingVersionManager(): void {
  _versionManager = null;
}
