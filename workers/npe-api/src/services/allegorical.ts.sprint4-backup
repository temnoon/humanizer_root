// Allegorical Projection Service - 5-stage narrative transformation
// Adapted from LPE projection.py for Cloudflare Workers

import type { Env, NPEPersona, NPENamespace, NPEStyle } from '../../shared/types';
import { createLLMProvider, type LLMProvider } from './llm-providers';

export type LengthPreference = 'shorter' | 'same' | 'longer' | 'much_longer';

export interface AllegoricalStage {
  name: string;
  prompt: string;
  result: string;
  duration_ms: number;
}

export interface AllegoricalResult {
  transformation_id: string;
  stages: {
    deconstruct: string;
    map: string;
    reconstruct: string;
    stylize: string;
  };
  final_projection: string;
  reflection: string;
  total_duration_ms: number;
}

/**
 * AllegoricalProjectionService - Transform narratives through 5-stage pipeline
 *
 * Pipeline: Deconstruct ‚Üí Map ‚Üí Reconstruct ‚Üí Stylize ‚Üí Reflect
 *
 * Based on LPE's TranslationChain approach with explicit multi-stage prompts
 */
export class AllegoricalProjectionService {
  private llmProvider: LLMProvider | null = null;

  constructor(
    private env: Env,
    private persona: NPEPersona,
    private namespace: NPENamespace,
    private style: NPEStyle,
    private userId: string,
    private modelId: string = '@cf/meta/llama-3.1-8b-instruct',
    private lengthPreference: LengthPreference = 'same'
  ) {}

  /**
   * Run the complete 5-stage allegorical transformation
   */
  async transform(sourceText: string): Promise<AllegoricalResult> {
    const startTime = Date.now();
    const stages: AllegoricalStage[] = [];

    // Initialize LLM provider
    this.llmProvider = await createLLMProvider(this.modelId, this.env, this.userId);

    // Stage 1: Deconstruct - Break down narrative into core elements
    const deconstructResult = await this.deconstruct(sourceText);
    stages.push(deconstructResult);

    // Stage 2: Map - Map elements to target namespace
    const mapResult = await this.map(deconstructResult.result);
    stages.push(mapResult);

    // Stage 3: Reconstruct - Rebuild narrative in new namespace
    const reconstructResult = await this.reconstruct(mapResult.result);
    stages.push(reconstructResult);

    // Stage 4: Stylize - Apply style and persona voice
    const stylizeResult = await this.stylize(reconstructResult.result);
    stages.push(stylizeResult);

    // Stage 5: Reflect - Generate meta-reflection on transformation
    const reflectResult = await this.reflect(sourceText, stylizeResult.result);
    stages.push(reflectResult);

    const totalDuration = Date.now() - startTime;

    // Create transformation record in database
    const transformationId = crypto.randomUUID();

    await this.env.DB.prepare(`
      INSERT INTO transformations (id, user_id, type, source_text, result_text, parameters, created_at)
      VALUES (?, ?, 'allegorical', ?, ?, ?, ?)
    `).bind(
      transformationId,
      this.userId,
      sourceText,
      stylizeResult.result,
      JSON.stringify({
        persona: this.persona.name,
        namespace: this.namespace.name,
        style: this.style.name,
        model: this.modelId,
        length_preference: this.lengthPreference,
        stage_token_budgets: {
          deconstruct: this.getStageTokenBudget(1),
          map: this.getStageTokenBudget(2),
          reconstruct: this.getStageTokenBudget(3),
          stylize: this.getStageTokenBudget(4),
          reflect: this.getStageTokenBudget(5)
        }
      }),
      Date.now()
    ).run();

    // Create allegorical projection record
    const projectionId = crypto.randomUUID();

    await this.env.DB.prepare(`
      INSERT INTO allegorical_projections (
        id, transformation_id, persona_id, namespace_id, style_id,
        stage_1_deconstruct, stage_2_map, stage_3_reconstruct,
        stage_4_stylize, stage_5_reflect
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    `).bind(
      projectionId,
      transformationId,
      this.persona.id,
      this.namespace.id,
      this.style.id,
      deconstructResult.result,
      mapResult.result,
      reconstructResult.result,
      stylizeResult.result,
      reflectResult.result
    ).run();

    return {
      transformation_id: transformationId,
      stages: {
        deconstruct: deconstructResult.result,
        map: mapResult.result,
        reconstruct: reconstructResult.result,
        stylize: stylizeResult.result,
      },
      final_projection: stylizeResult.result,
      reflection: reflectResult.result,
      total_duration_ms: totalDuration
    };
  }

  /**
   * Stage 1: Deconstruct narrative into core elements
   * Content-aware: preserves the type of discourse (argument, story, analysis, etc.)
   */
  private async deconstruct(text: string): Promise<AllegoricalStage> {
    const startTime = Date.now();

    const systemPrompt = `You are analyzing the structure of meaning in discourse.
Your task is to identify core elements WITHOUT changing what type of discourse it is.
If it's an argument, identify claims and evidence. If it's a story, identify characters and events.
If it's analysis, identify concepts and relationships. Preserve the essence.`;

    const prompt = `Identify the fundamental elements of this discourse:

${text}

**STEP 1: IDENTIFY PRIMARY STRUCTURAL TYPE**

**CRITICAL: Check types from MOST SPECIFIC to LEAST SPECIFIC**

Go through this checklist in order. The FIRST match wins.

**CHECK 1: DRAMATIC TYPES (most distinctive markers)**

Type 14 - SCREENPLAY?
- ‚úì Scene headings like "INT. OFFICE - DAY" or "EXT. STREET - NIGHT"
- ‚úì Character names CENTERED above dialogue
- ‚úì Action lines in present tense
‚Üí If YES: **PRIMARY TYPE: Type 14 - SCREENPLAY** [STOP HERE]

Type 13 - STAGE PLAY?
- ‚úì Character names before dialogue (in caps or bold)
- ‚úì Stage directions in (parentheses) or [brackets]
- ‚úì ACT/SCENE divisions
‚Üí If YES: **PRIMARY TYPE: Type 13 - STAGE PLAY** [STOP HERE]

Type 15 - INTERACTIVE DIALOGUE?
- ‚úì Choice nodes like [Player choice:] or [Option A/B]
- ‚úì Branching logic or conditional responses
- ‚úì Decision points with outcomes
‚Üí If YES: **PRIMARY TYPE: Type 15 - INTERACTIVE DIALOGUE** [STOP HERE]

**CHECK 2: VERSE TYPES (line-based, not paragraph-based)**

Type 10 - POETRY (Fixed Form)?
- ‚úì Exactly 14 lines (sonnet) OR 3 lines with 5-7-5 syllables (haiku) OR other fixed pattern
- ‚úì Prescribed meter and rhyme scheme
- ‚úì Line breaks for metrical reasons, not sentence breaks
‚Üí If YES: **PRIMARY TYPE: Type 10 - POETRY (Fixed Form)** [STOP HERE]

Type 12 - SONG LYRICS?
- ‚úì [Verse], [Chorus], [Bridge] labels OR clear verse/chorus repetition
- ‚úì Singable phrasing with rhyme
- ‚úì Musical structure
‚Üí If YES: **PRIMARY TYPE: Type 12 - SONG LYRICS** [STOP HERE]

**CHECK 3: SPECIFIC PROSE TYPES (distinctive structural markers)**

Type 8 - ADVICE/INSTRUCTION?
- ‚úì Second-person "you" addressing reader
- ‚úì Imperative verbs ("do this", "try", "consider")
- ‚úì Action steps or recommendations
- ‚úì "TL;DR: If you..." or "Here's how to..."
‚Üí If YES: **PRIMARY TYPE: Type 8 - ADVICE/INSTRUCTION** [STOP HERE]

Type 1 - STORY?
- ‚úì Dialogue in quotes: "She said..." or character speech
- ‚úì Character actions in past tense: "He walked", "She replied"
- ‚úì Scene description with specific time/place/people
- ‚úì Events happening in temporal sequence
**NOTE**: Even if text ALSO contains commentary, if it has actual scenes/dialogue, it's STORY
‚Üí If YES: **PRIMARY TYPE: Type 1 - STORY** [STOP HERE]

Type 4 - CASE STUDY?
- ‚úì Third-person observation of specific situation
- ‚úì Problem ‚Üí Analysis ‚Üí Resolution structure
- ‚úì Evidence-based sections
- ‚úì Clinical or academic framing
‚Üí If YES: **PRIMARY TYPE: Type 4 - CASE STUDY** [STOP HERE]

Type 2 - MEMOIR?
- ‚úì First-person "I" + past tense
- ‚úì Autobiographical (real life events, not fiction)
- ‚úì Retrospective reflection on personal experiences
- ‚úì "I remember..." or "When I was..." tone
**NOTE**: If it's JUST memory without analytical insights, it's MEMOIR not PERSONAL ESSAY
‚Üí If YES: **PRIMARY TYPE: Type 2 - MEMOIR** [STOP HERE]

Type 9 - REVIEW/CRITIQUE?
- ‚úì Evaluating something (product, book, film, service)
- ‚úì Assessment criteria explicitly stated or implied
- ‚úì Rating or judgment given
- ‚úì Recommendation (buy/don't buy, worth it/not worth it)
‚Üí If YES: **PRIMARY TYPE: Type 9 - REVIEW/CRITIQUE** [STOP HERE]

Type 6 - EXPLANATION?
- ‚úì Explaining how something works or why it happens
- ‚úì Theory or mechanism PLUS specific concrete examples
- ‚úì "Consider the case of [specific example]..." or similar
- ‚úì Mixed abstraction (both abstract principles AND concrete instances)
**NOTE**: Must have BOTH theory AND examples. If only abstract, check ANALYSIS next.
‚Üí If YES: **PRIMARY TYPE: Type 6 - EXPLANATION** [STOP HERE]

**CHECK 4: GENERAL PROSE TYPES (use only if nothing above matched)**

**NOTE**: PERSUASIVE ARGUMENT removed - persuasion is a RHETORICAL MODE, not a structural type.
Stories can persuade, analyses can persuade, explanations can argue. Focus on STRUCTURE, not intent.

Type 5 - ANALYSIS?
- ‚úì Interpretive examination of subject
- ‚úì Applying framework to understand something
- ‚úì "This reveals...", "demonstrates...", "shows..."
- ‚úì NOT persuading, just interpreting
**NOTE**: Use this if examining subject WITHOUT persuasive intent and WITHOUT concrete examples
‚Üí If YES: **PRIMARY TYPE: Type 5 - ANALYSIS** [STOP HERE]

Type 3 - PERSONAL ESSAY?
- ‚úì First-person "I" + experiences
- ‚úì Narrative examples PLUS analytical/universal insights
- ‚úì Blends personal story with broader observations
- ‚úì Reflective, not just memoir
**NOTE**: ONLY use this if text has BOTH personal narrative AND analytical insights. If just story, use STORY or MEMOIR instead.
‚Üí If YES: **PRIMARY TYPE: Type 3 - PERSONAL ESSAY** [STOP HERE]

Type 11 - POETRY (Free Verse)?
- ‚úì Line breaks for emphasis (not sentence breaks)
- ‚úì No prescribed meter/rhyme
- ‚úì Visual arrangement on page matters
- ‚úì Stanza organization, not paragraphs
‚Üí If YES: **PRIMARY TYPE: Type 11 - POETRY (Free Verse)** [STOP HERE]

**IF NONE OF THE ABOVE MATCHED**: Re-read the text and find the CLOSEST match. Don't skip type detection.

**PRIMARY TYPE for this text**: [Type X - NAME]

**DISTINGUISH PRIMARY FROM SECONDARY CONTENT**

If text contains BOTH narrative AND commentary:

**Look for PRIMARY indicators:**
- Dialogue in quotes: "She is tolerable..."
- Character actions: "Elizabeth overheard", "Darcy replied"
- Scene description: specific time/place/people

**Ignore SECONDARY indicators:**
- Meta-commentary: "This establishes..."
- Literary analysis: "demonstrates skill"
- Abstract observations: "reveals through"

**Decision rule:**
IF text contains dialogue OR character actions in scenes:
  ‚Üí PRIMARY TYPE = STORY (Type 1) (even if commentary present)
ELSE IF first-person retrospective:
  ‚Üí Check MEMOIR vs. PERSONAL ESSAY vs. STORY
ELSE IF second-person imperatives:
  ‚Üí Check ADVICE vs. EXPLANATION

**Tag the result:**
[PRIMARY: Type X - NAME] [SECONDARY: commentary/none]

**For remaining stages:** Use ONLY the PRIMARY type. Ignore secondary content.

**STEP 2: LIST ALL ELEMENTS (keeping abstraction level)**

Then identify:
1. Core concepts or entities (what this is ABOUT)
   - If STORY: List actual character names (not "characters")
   - If EXPLANATION: List BOTH concepts AND specific examples
   - Example: "Natural selection (concept), woodpecker (example)"
2. Key claims or actions (what is SAID or HAPPENS)
3. Relationships (how concepts/entities relate)
4. Tensions (conflicts, paradoxes, problems, challenges)
5. Resolutions or outcomes (conclusions, results, implications)

**CRITICAL RULES**:
- Preserve abstraction level: Concrete stays concrete, abstract stays abstract
- For SPECIFIC EXAMPLES: List them explicitly, don't generalize
  - ‚úÖ "woodpecker, mistletoe" (specific)
  - ‚ùå "organisms, beings" (too general)
- Do NOT invent examples. Do NOT create fiction. Extract what's actually there.
- Tag concrete examples: [CONCRETE: woodpecker, mistletoe] so later stages preserve them`;

    const result = await this.callLLM(systemPrompt, prompt, 1);

    return {
      name: 'Deconstruct',
      prompt: prompt,
      result: result,
      duration_ms: Date.now() - startTime
    };
  }

  /**
   * Stage 2: Map elements to target namespace
   * CRITICAL: Translate concepts, DON'T create fiction
   */
  private async map(deconstructedText: string): Promise<AllegoricalStage> {
    const startTime = Date.now();

    const systemPrompt = `You are translating concepts between conceptual frameworks.
${this.namespace.context_prompt}

CRITICAL RULES:
- If the source is an ARGUMENT, translate to an argument in this framework
- If the source is ANALYSIS, translate to analysis in this framework
- If the source is a STORY, only then translate to a story
- DO NOT invent concrete examples that weren't in the source
- PRESERVE the abstraction level - if source is abstract/conceptual, keep it abstract
- Translate VOCABULARY and CONCEPTUAL FRAMEWORK, not create new content`;

    const prompt = `Translate these elements into the conceptual framework of ${this.namespace.description}:

Source Elements:
${deconstructedText}

**CRITICAL: PRESERVE DISCOURSE TYPE FROM STAGE 1**
The Stage 1 analysis identified this as: [extract type from deconstructedText]
You MUST maintain that same type in your mapping.

**CRITICAL: PRESERVE ABSTRACTION LEVEL**

For each element, find the EQUIVALENT (not abstracted) concept in ${this.namespace.name} framework.

**TRANSLATION RULES**:

1. **ABSTRACT ‚Üí ABSTRACT**:
   - "Empiricism" ‚Üí "Empirical study"
   - "Causation" ‚Üí "Mechanical necessity"

2. **CONCRETE ‚Üí CONCRETE** (DO NOT ABSTRACT):
   - "Woodpecker's beak" ‚Üí [Find equivalent specific example in ${this.namespace.name}]
   - Example: "Galileo's telescope" (specific tool, not "instruments")
   - "Elizabeth Bennet" ‚Üí [Find equivalent character in ${this.namespace.name}]
   - Example: "Miss Havisham" (specific person, not "woman")

3. **MIXED ‚Üí MIXED** (Preserve BOTH):
   - Theory + Examples ‚Üí Theory + Examples
   - Characters + Themes ‚Üí Characters + Themes

**FOR CONCRETE EXAMPLES**:
If source mentions "woodpecker", your output MUST include a specific equivalent:
‚úÖ "Woodpecker ‚Üí Diving bird of the Thames estuary"
‚úÖ "Mistletoe ‚Üí Climbing vine of tropical conservatories"
‚ùå "Woodpecker ‚Üí Organism" (too abstract - WRONG)
‚ùå "Mistletoe ‚Üí Plant" (too abstract - WRONG)

**FOR STORY CHARACTERS**:
If source mentions "Elizabeth", your output MUST include a character:
‚úÖ "Elizabeth Bennet ‚Üí Sarah Marwick of Cheapside"
‚ùå "Elizabeth ‚Üí Individual" (too abstract - WRONG)

Provide structured mapping that:
- Preserves discourse type
- Maintains abstraction level
- Provides concrete equivalents for concrete examples`;

    const result = await this.callLLM(systemPrompt, prompt, 2);

    return {
      name: 'Map',
      prompt: prompt,
      result: result,
      duration_ms: Date.now() - startTime
    };
  }

  /**
   * Stage 3: Reconstruct in new conceptual framework
   * Preserves discourse type while using new vocabulary
   */
  private async reconstruct(mappedText: string): Promise<AllegoricalStage> {
    const startTime = Date.now();

    const systemPrompt = `You are expressing ideas through a specific conceptual framework.
${this.namespace.context_prompt}

Your task is to reconstruct the SAME MEANING using the vocabulary and concepts of this framework.

**TYPE LOCK**: The discourse type was identified in Stage 1. You MUST preserve that exact type.`;

    const prompt = `Using these translated elements, reconstruct the discourse entirely within ${this.namespace.description} framework:

Translated Elements:
${mappedText}

**STEP 0: VALIDATE TYPE CONSISTENCY** ‚ö†Ô∏è CRITICAL

1. Read the Stage 1 output above
2. Extract the PRIMARY TYPE detected in Stage 1 (should be "Type X - NAME")
3. If you cannot find the PRIMARY TYPE, ABORT and report error
4. The type you lock in Step 2 MUST match the type detected in Stage 1
5. If detected type ‚â† intended locked type, ABORT and report error

**Example validation:**
Stage 1 detected: [PRIMARY: Type 5 - ANALYSIS]
Stage 3 must lock: Type 5 - ANALYSIS
‚ùå If you are tempted to lock Type 6 - EXPLANATION instead, STOP and report error
‚úÖ Only proceed if types match exactly

**STEP 1: EXTRACT TYPE FROM STAGE 1**
Look at the Stage 1 output above. Find the PRIMARY TYPE tag.
The PRIMARY TYPE is: [Type X - ___________]

**STEP 2: ACTIVATE TYPE LOCK**

üîí **TYPE LOCK ACTIVATED: [Insert Type X - NAME from Stage 1]**

This text was identified as [Type X - NAME] in Stage 1.
You MUST maintain this exact type through reconstruction.
Changing the type is a CRITICAL ERROR.

**STEP 3: TYPE-SPECIFIC RECONSTRUCTION RULES**

**NARRATIVE PROSE:**

IF TYPE 1 - STORY:
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
‚úÖ **REQUIRED OUTPUT FORMAT:**
- Write as NARRATIVE SCENE (characters doing/saying things)
- Use translated character names: "The Governor walked..." "Miss Havisham replied..."
- Include DIALOGUE (in quotes) or CHARACTER ACTIONS (in past tense)
- Show EVENTS HAPPENING (not analysis of events)

‚ùå **FORBIDDEN PATTERNS:**
- ‚ùå "The Anatomy of [topic]" (treatise title)
- ‚ùå "Observations on [topic]" (analytical title)
- ‚ùå "We shall examine..." (analytical framing)
- ‚ùå "Consider the case of..." (when discussing characters)

‚úÖ **PRESERVATION RULE:** Preserve scene structure, dialogue, character actions, plot events
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

IF TYPE 2 - MEMOIR:
- First-person retrospective narrative
- Personal experiences with reflective tone
- "I remember...", autobiographical perspective
‚úÖ **PRESERVATION RULE:** Preserve first-person voice, personal experiences, reflective tone

IF TYPE 3 - PERSONAL ESSAY:
- First-person narrative examples + analytical insights
- Personal anecdotes balanced with universal observations
- Blend of narrative and reflection
‚úÖ **PRESERVATION RULE:** Preserve narrative examples + analytical insights balance

IF TYPE 4 - CASE STUDY:
- Third-person observational, problem-analysis-resolution structure
- Structured sections with evidence
‚úÖ **PRESERVATION RULE:** Preserve problem structure, evidence-based analysis

**ANALYTICAL/EXPOSITORY PROSE:**

IF TYPE 5 - ANALYSIS:
- Output MUST analyze/interpret with framework
- Maintain interpretive examination structure
- Apply framework to subject
‚úÖ **PRESERVATION RULE:** Preserve interpretive framework, subject examination, analytical structure

IF TYPE 6 - EXPLANATION:
- Output MUST explain mechanism/theory
- Include BOTH abstract principles AND concrete examples
- Use specific examples from Stage 2 mapping
‚ùå **CRITICAL:** Do NOT drop concrete examples (this was C1 regression in Sprint 3)
‚úÖ **DO include:** "Consider the case of [specific example]..."
‚úÖ **PRESERVATION RULE:** Preserve concrete examples exactly, preserve abstract+concrete balance

IF TYPE 8 - ADVICE/INSTRUCTION:
- Second-person address ("you")
- Recommendations + action steps
- Imperative mood, practical guidance
‚úÖ **PRESERVATION RULE:** Preserve second-person address, action steps, practical recommendations

IF TYPE 9 - REVIEW/CRITIQUE:
- Evaluative assessment with criteria
- Ratings, judgments, recommendations
- Subject description + evaluation
‚úÖ **PRESERVATION RULE:** Preserve evaluative criteria, assessment structure, recommendations

**VERSE:**

IF TYPE 10 - POETRY (Fixed Form):
- Preserve prescribed structure (sonnet = 14 lines, haiku = 5-7-5, etc.)
- Maintain meter and rhyme scheme
- Line breaks and stanza pattern
‚úÖ **PRESERVATION RULE:** Preserve line count, meter, rhyme scheme, stanza pattern exactly

IF TYPE 11 - POETRY (Free Verse):
- Preserve line-based structure (not paragraph-based)
- Maintain visual arrangement and enjambment
- Stanza organization
‚úÖ **PRESERVATION RULE:** Preserve line breaks, stanza organization, visual arrangement

IF TYPE 12 - SONG LYRICS:
- Preserve verse/chorus/bridge structure
- Maintain repetition patterns
- Singable phrasing
‚úÖ **PRESERVATION RULE:** Preserve verse/chorus/bridge, repetition, musical phrasing

**DRAMATIC:**

IF TYPE 13 - STAGE PLAY:
- Preserve act/scene structure
- Character names before dialogue
- Stage directions in parentheses
‚úÖ **PRESERVATION RULE:** Preserve scene structure, character names, stage directions

IF TYPE 14 - SCREENPLAY:
- Preserve scene headings (INT./EXT., location, time)
- Action lines in present tense
- Character names centered above dialogue
‚úÖ **PRESERVATION RULE:** Preserve scene heading format, action lines, dialogue format

IF TYPE 15 - INTERACTIVE DIALOGUE:
- Preserve choice nodes and branching structure
- Conditional logic
- Decision points
‚úÖ **PRESERVATION RULE:** Preserve choice nodes, branching logic, interactive structure

**ABSTRACTION PRESERVATION**:
- If Stage 2 mapping included concrete examples ‚Üí OUTPUT MUST INCLUDE THEM
- If Stage 2 mapping was pure abstract ‚Üí OUTPUT stays abstract
- Match the abstraction level of the input

**STEP 4: VERIFY BEFORE OUTPUTTING**
Before writing, check:
‚ñ° Does my output match the PRIMARY TYPE from Stage 1?
‚ñ° Am I using forbidden patterns for this type?
‚ñ° Is this what the user would expect for this type?

Now write the reconstructed discourse in ${this.namespace.name} framework.`;

    const result = await this.callLLM(systemPrompt, prompt, 3);

    return {
      name: 'Reconstruct',
      prompt: prompt,
      result: result,
      duration_ms: Date.now() - startTime
    };
  }

  /**
   * Stage 4: Apply style and persona voice
   * Voice and register, NOT content changes
   */
  private async stylize(reconstructedText: string): Promise<AllegoricalStage> {
    const startTime = Date.now();

    const systemPrompt = `You are applying a specific voice and stylistic register to discourse.
${this.persona.system_prompt}

${this.style.style_prompt}

Your task is to express the SAME CONTENT in your distinctive voice.
Change ONLY the linguistic style, NOT the substance or structure.`;

    const prompt = `Apply ${this.persona.name} voice and ${this.style.name} style to this discourse:

Source:
${reconstructedText}

**FIRST: IDENTIFY THE TYPE**:
What type of discourse is this? [Type 1-15 from Stage 1/3]

**CRITICAL: PERSONA AFFECTS VOICE, NOT TYPE**

Your persona is: ${this.persona.name}
Your task: Apply this persona's VOICE to the text
Your constraint: Do NOT change the discourse TYPE

**Understanding the distinction:**

TYPE = The structure/format (15 structural types: story, memoir, essay, analysis, explanation, argument, advice, review, poetry, song, play, screenplay, dialogue)
VOICE = How you say it (analytical tone, innocent wonder, formal precision, etc.)

**Examples of correct voice application:**

IF TYPE 1 (STORY) + PERSONA = holmes_analytical:
‚ùå WRONG: "Let us examine the dynamics of these characters" (converted to analysis)
‚úÖ RIGHT: "One observed the gentleman's disdain..." (narrative with analytical voice)

IF TYPE 2 (MEMOIR) + PERSONA = holmes_analytical:
‚ùå WRONG: "Let us analyze this personal experience" (converted to analysis)
‚úÖ RIGHT: "I recall, with analytical clarity, the moment when..." (memoir with analytical voice)

IF TYPE 3 (PERSONAL ESSAY) + PERSONA = holmes_analytical:
‚úÖ RIGHT: "I observed in my own experience that..." (first-person + analytical insights - natural fit)

IF TYPE 8 (ADVICE) + PERSONA = holmes_analytical:
‚ùå WRONG: "One must examine the phenomenon of career transitions" (converted to analysis)
‚úÖ RIGHT: "You should, after careful analysis, consider these steps..." (advice with analytical voice)

**Your specific task for TYPE = [extract number and name from source]:**

**NARRATIVE PROSE (Types 1-4):**
- Type 1 (STORY): Keep narrative scene with characters/dialogue, apply voice to narration
- Type 2 (MEMOIR): Keep first-person retrospective, apply voice to reflection
- Type 3 (PERSONAL ESSAY): Keep first-person + insights, apply voice to both
- Type 4 (CASE STUDY): Keep problem-analysis-resolution, apply voice to analysis

**ANALYTICAL/EXPOSITORY (Types 5-9):**
- Type 5 (ANALYSIS): Keep interpretive framework, apply voice to interpretation
- Type 6 (EXPLANATION): Keep theory + examples, apply voice to exposition
- Type 8 (ADVICE): Keep second-person recommendations, apply voice to guidance
- Type 9 (REVIEW): Keep evaluative criteria, apply voice to assessment

**VERSE (Types 10-12):**
- Type 10 (POETRY - Fixed): Keep meter/rhyme/structure, apply voice to imagery
- Type 11 (POETRY - Free): Keep line breaks/arrangement, apply voice to language
- Type 12 (SONG LYRICS): Keep verse/chorus structure, apply voice to lyrical content

**DRAMATIC (Types 13-15):**
- Type 13 (STAGE PLAY): Keep scene structure/dialogue, apply voice to character speech
- Type 14 (SCREENPLAY): Keep scene headings/action, apply voice to dialogue/description
- Type 15 (INTERACTIVE DIALOGUE): Keep choice nodes, apply voice to character options

**Forbidden conversions (any type ‚Üí different type):**
- STORY ‚Üí Analysis ‚ùå
- MEMOIR ‚Üí Analytical essay ‚ùå
- ADVICE ‚Üí Story about advice ‚ùå
- POETRY ‚Üí Prose explanation ‚ùå
- SCREENPLAY ‚Üí Narrative description ‚ùå

**The TYPE is sacred. The VOICE is flexible.**

**Style requirements**:
- Apply ${this.persona.description.toLowerCase()} perspective and voice
- Use ${this.style.name} stylistic characteristics
- Preserve ALL content, claims, structure, and TYPE from source
- Change ONLY word choice, sentence structure, and rhetorical devices within that type

**TYPE MUST MATCH SOURCE EXACTLY**:
Extract the type number and name from Stage 3, then apply voice within that structure.

Do NOT change what is being said or what type it is, only HOW it is said.

Write the styled version.`;

    const result = await this.callLLM(systemPrompt, prompt, 4);

    return {
      name: 'Stylize',
      prompt: prompt,
      result: result,
      duration_ms: Date.now() - startTime
    };
  }

  /**
   * Stage 5: Generate reflection on the transformation
   */
  private async reflect(originalText: string, finalText: string): Promise<AllegoricalStage> {
    const startTime = Date.now();

    const systemPrompt = `You are a literary analyst reflecting on narrative transformations.
Provide insightful meta-commentary on how the transformation process revealed new meanings.`;

    const prompt = `Reflect on this allegorical transformation:

Original Narrative:
${originalText}

Final Allegorical Projection (in ${this.namespace.name}, told by ${this.persona.name} in ${this.style.name} style):
${finalText}

Provide a reflection that:
1. Identifies what core elements were preserved across the transformation
2. Explains what new insights emerged through the allegorical lens
3. Discusses how the ${this.namespace.name} setting illuminated aspects of the original
4. Analyzes how the ${this.persona.name} perspective shaped the narrative
5. Considers what was gained or lost in translation

Write a thoughtful reflection (2-3 paragraphs).`;

    const result = await this.callLLM(systemPrompt, prompt, 5);

    return {
      name: 'Reflect',
      prompt: prompt,
      result: result,
      duration_ms: Date.now() - startTime
    };
  }

  /**
   * Get token budget for a specific stage with length preference applied
   *
   * Per-stage base budgets:
   * - Stage 1 (Deconstruct): 800 tokens - Lists elements
   * - Stage 2 (Map): 1000 tokens - Creates mappings
   * - Stage 3 (Reconstruct): 2000 tokens - Full narrative
   * - Stage 4 (Stylize): 2000 tokens - Full narrative with style
   * - Stage 5 (Reflect): 1000 tokens - Meta-analysis
   *
   * Length preference multipliers:
   * - shorter: 0.5x base
   * - same: 1.0x base
   * - longer: 1.5x base
   * - much_longer: 2.0x base
   */
  private getStageTokenBudget(stage: number): number {
    // Base budgets per stage (optimized for narrative flow)
    const baseBudgets: Record<number, number> = {
      1: 800,   // Deconstruct: List elements
      2: 1000,  // Map: Create mappings
      3: 2000,  // Reconstruct: Full narrative
      4: 2000,  // Stylize: Full narrative with style
      5: 1000   // Reflect: Meta-analysis
    };

    const base = baseBudgets[stage] || 1000;

    // Apply length preference multiplier
    const multipliers: Record<LengthPreference, number> = {
      shorter: 0.5,
      same: 1.0,
      longer: 1.5,
      much_longer: 2.0
    };

    const multiplier = multipliers[this.lengthPreference] || 1.0;
    return Math.ceil(base * multiplier);
  }

  /**
   * Call LLM using the configured provider with per-stage token budget
   */
  private async callLLM(systemPrompt: string, userPrompt: string, stage: number): Promise<string> {
    if (!this.llmProvider) {
      throw new Error('LLM provider not initialized');
    }

    const maxTokens = this.getStageTokenBudget(stage);

    try {
      const response = await this.llmProvider.call({
        messages: [
          { role: 'system', content: systemPrompt },
          { role: 'user', content: userPrompt }
        ],
        max_tokens: maxTokens,
        temperature: 0.7
      });

      return response.response || '';
    } catch (error) {
      console.error('LLM call failed:', error);
      throw new Error(`Failed to generate transformation stage: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }
}
