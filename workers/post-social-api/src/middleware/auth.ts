// JWT validation middleware for post-social-api
// Validates tokens generated by npe-api
import { Context } from 'hono';
import * as jose from 'jose';

export interface AuthContext {
  userId: string;
  email: string;
  role: string;
}

export interface RequireAuthOptions {
  // Require one of these roles (if specified)
  roles?: string[];
}

/**
 * Verify JWT token from npe-api
 */
export async function verifyToken(token: string, secret: string): Promise<AuthContext | null> {
  try {
    const encoder = new TextEncoder();
    const secretKey = encoder.encode(secret);

    const { payload } = await jose.jwtVerify(token, secretKey);

    return {
      userId: payload.userId as string,
      email: payload.email as string,
      role: payload.role as string,
    };
  } catch (error) {
    console.error('[AUTH] Token verification failed:', error);
    return null;
  }
}

/**
 * Hono middleware to require authentication
 * Validates JWT tokens from npe-api
 * 
 * @param options.roles - If provided, user must have one of these roles
 */
export function requireAuth(options: RequireAuthOptions = {}) {
  return async (c: Context, next: () => Promise<void>) => {
    const authHeader = c.req.header('Authorization');

    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      return c.json({ error: 'Missing or invalid authorization header' }, 401);
    }

    const token = authHeader.substring(7);
    const authContext = await verifyToken(token, c.env.JWT_SECRET);

    if (!authContext) {
      return c.json({ error: 'Invalid or expired token' }, 401);
    }

    // Check role if required
    if (options.roles && options.roles.length > 0) {
      if (!options.roles.includes(authContext.role)) {
        return c.json({
          error: 'Insufficient permissions',
          required: options.roles,
          current: authContext.role,
        }, 403);
      }
    }

    // Add auth context to request
    c.set('auth', authContext);

    await next();
  };
}

/**
 * Optional authentication middleware
 * Attempts to authenticate but doesn't require it
 * Sets auth context if token is valid, null otherwise
 */
export function optionalAuth() {
  return async (c: Context, next: () => Promise<void>) => {
    const authHeader = c.req.header('Authorization');

    if (authHeader && authHeader.startsWith('Bearer ')) {
      const token = authHeader.substring(7);
      const authContext = await verifyToken(token, c.env.JWT_SECRET);
      
      if (authContext) {
        c.set('auth', authContext);
      }
    }

    await next();
  };
}

/**
 * Optional auth for local development
 * Skips authentication if ENVIRONMENT is 'local' or 'development'
 */
export function optionalLocalAuth() {
  return async (c: Context, next: () => Promise<void>) => {
    const isLocalDev = !c.env?.ENVIRONMENT ||
                      c.env.ENVIRONMENT === 'local' ||
                      c.env.ENVIRONMENT === 'development';

    if (isLocalDev) {
      c.set('auth', {
        userId: 'test-user-local',
        email: 'local@test.com',
        role: 'pro'
      });
      await next();
      return;
    }

    // Production: require auth
    const authHeader = c.req.header('Authorization');

    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      return c.json({ error: 'Missing authorization header' }, 401);
    }

    const token = authHeader.substring(7);
    const authContext = await verifyToken(token, c.env.JWT_SECRET);

    if (!authContext) {
      return c.json({ error: 'Invalid or expired token' }, 401);
    }

    c.set('auth', authContext);
    await next();
  };
}

/**
 * Get authenticated user from context
 * Returns null if not authenticated (when using optionalAuth)
 */
export function getAuthContext(c: Context): AuthContext | null {
  return c.get('auth') as AuthContext | null;
}

/**
 * Check if user has a specific role
 */
export function hasRole(c: Context, role: string): boolean {
  const auth = getAuthContext(c);
  return auth?.role === role;
}

/**
 * Check if user has any of the specified roles
 */
export function hasAnyRole(c: Context, roles: string[]): boolean {
  const auth = getAuthContext(c);
  return auth ? roles.includes(auth.role) : false;
}

/**
 * Wheel roles - admin/root access
 * Old-school Unix naming: users in the 'wheel' group have sudo
 */
const WHEEL_ROLES = ['admin', 'wheel', 'root', 'superadmin'];

/**
 * Check if user is in the wheel group (admin/root access)
 * Wheel users can bypass ownership checks
 */
export function isWheel(c: Context): boolean {
  const auth = getAuthContext(c);
  return auth ? WHEEL_ROLES.includes(auth.role) : false;
}

/**
 * Check if user owns resource OR is wheel
 */
export function isOwnerOrWheel(c: Context, ownerId: string): boolean {
  const auth = getAuthContext(c);
  if (!auth) return false;
  if (WHEEL_ROLES.includes(auth.role)) return true;
  return auth.userId === ownerId;
}
